<!DOCTYPE html>
<!--
Èé¨—ÜÂÖòÊµºÊ®∫ÂØ≤ÁíáÂ≠òÊßëÈîõÂ†¢–©Èçî„ÑßÓÅ¨/ÂØ∞ÓÜª‰øäÈñ≤Â∂áÂÅ£ÈîõÂ§õÁ¥∞
1) ÁªâÂ©öÊ´é visualViewport.scroll ÁëôÔπÄÂΩÇÈîõÂ≤Ñ‰º©ÈçèÂ∂ÖÊπ¥Èçß‚Ç¨ÈèçÂøîÁ≤¥Èçî„Ñ•Óá±Èë∑ÊíÆÁèÆÊ£∞?resize Èé∂Ê†ßÂß©ÈäÜ?
2) resize ÈèÄÈÄõË¥ü requestAnimationFrame Èë∫ÂÇõÁ•¶ÈîõÂ±ΩÊÇìÊ∂ì‚Ç¨ÁîØ—ÉÂΩßÈéµ—ÜÓîëÊ∂ì‚Ç¨Â®Ü?applyViewportSizeÈäÜ?
3) applyViewportSize ÊæßÁÇ≤Âßû early-returnÈîõÂ†ùÊòÇÁÄµÁ®øÂΩâÈçñ?<2px Èê©Â≠òÂ∏¥Êù©ÊñøÊ¥ñÈîõÂ§õÁ¥ùÈñ¨ÂûÆÂé§Èñ≤Â∂ÖÓò≤Èñ≤Â∂àÓÜïÈê¢ËØ≤Á´∑ÈäÜ?
4) Êù©ÊÑØÓîëÊ∂ìÓÖ†Á¥¶ÁÄõÊ©ÄÂô∏ÂØ§ÂìÑÓñÉÈçîÁä≥ÊΩØÊµ†Â†ïÊ£¨Èé∫—çÁ¥∞Êµ†?DPR ÈçôÊ®∫ÂØ≤Èé¥?minDim ÈçôÊ®∫ÂØ≤ÁìíÂë∞ÁπÉ 9% ÈèÉÊÉ∞–ïÈçôÊàô‚Ç¨?
5) Èêì—ÖÂ¢ñÁºÇÊí≥Áì®ÈèÄÈÄõË¥üÈçíÂóóÊäöÊæßÁÇ∫Âô∫Èñ≤Â∂ÖÁºìÈîõÂ†üÁò°ÁîØ?1~2 ÂØÆÁãÖÁ¥öÈîõÂ≤ÑÊßªÂßù„à†Â¥üÁîØ—áÊ®ÜÊøâÁÇ™‚Ç¨?
6) finale ÈóÉËàµÓÜåÁí∫ÂÆ†ÁπÉÈêì—ÖÂ¢ñÁºÇÊí≥Áì®Èñ≤Â∂ÖÁºìÈîõÂ≤Ñ‰º©ÈçèÂ∂ÜÊ£§ÈèÅÂ†ùÁ¥ëÈñø‚Ç¨ÈäÜ?
7) ÁªâËØ≤Âß©ÁªîÓàûÊ™∑Êµ£?lighter/shadowBlur/centerFlash/fog Èê®Âã´Á¥ëÈñø‚Ç¨ÈîõÂ±ºÁ∂ÜÈçîÁÜª‚Ç¨Ê•ÑÁπòÊ∂ì‚Ç¨Âßù„É©Ê™∑Áªæ—Å‚Ç¨?
8) ÁªÆÊéëÁìôÈçôÊàùÁö†ÈçîÁä≤ÂèÜÊ∂ì„É¶Áâ∏Ê£∞Âã≠ÁïªÈóÑÊÑ≠Á•¶ÈîõÂ≤Ñ‰º©ÈçèÂ∂áÁÅõÈèÉË∑∫Âò≤ÈçäÁÖéÓá±Èë∑Â≠òÂ∏ÄÁîØ—ÉÁö∑ÂÆÑËà¨‚Ç¨?
9) rAF Èé≠„à†Óò≤ÈèÉÂ†ïÊå∏ÈçíË∑∫„Åá dtÈîõÂ≤ÑÊ™∑Êµ£Â∫°ÊÇóÈçôÊùøÂûèÈç•ÁÇ≤Â¢†ÈçôÊùøÊÇóÈê®ÂãØÊ£ØÈêë‰Ω∑Á¨åÈçóÔø†„ÄëÈäÜ?
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>XYTÊñ∞Âπ¥Âø´‰πê</title>
    <style>
        :root {
            --vvh: 100vh;
            --title-main-size: 72px;
            --title-sub-size: 66px;
            --title-gap-size: 12px;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
            background: #060609;
            font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", Arial, sans-serif;
        }

        #app {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            overflow: hidden;
            background:
                radial-gradient(120% 120% at 50% 100%, rgba(170, 20, 20, 0.20) 0%, rgba(18, 12, 22, 0.42) 52%, rgba(7, 7, 10, 0.96) 100%),
                linear-gradient(180deg, #120913 0%, #09070d 100%);
        }

        @supports (height: 100dvh) {
            #app {
                height: 100dvh;
            }
        }

        @supports not (height: 100dvh) {
            #app {
                height: 100svh;
            }
        }

        #canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            display: block;
        }

        @supports (height: 100dvh) {
            #canvas {
                height: 100dvh;
            }
        }

        @supports not (height: 100dvh) {
            #canvas {
                height: 100svh;
            }
        }

        #startOverlay {
            position: absolute;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            z-index: 8;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            transition: opacity 0.8s ease;
            background: transparent;
            opacity: 1;
        }

        #startOverlay.hide {
            opacity: 0;
        }

        .festive-wrap {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            max-width: none;
            padding: 20px 16px 22px;
            border-radius: 0;
            background: radial-gradient(circle at 50% 35%, rgba(120, 20, 20, 0.42) 0%, rgba(35, 8, 10, 0.52) 75%, rgba(0, 0, 0, 0.16) 100%);
            border: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        .title {
            margin: 0;
            font-family: "STKaiti", "Kaiti SC", "KaiTi", "STXingkai", "Xingkai SC", "Songti SC", serif;
            font-weight: 900;
            line-height: 1.08;
            letter-spacing: 0.04em;
            font-size: clamp(44px, 9vw, 120px);
            background: linear-gradient(132deg, #fff8da 0%, #ffe79a 18%, #ffd66a 38%, #ffba2f 58%, #ffcf68 76%, #fff2c6 100%);
            background-size: 240% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            text-shadow:
                0 0 8px rgba(255, 240, 185, 0.75),
                0 0 20px rgba(255, 214, 112, 0.55),
                0 0 32px rgba(255, 176, 45, 0.42),
                0 1px 0 rgba(140, 62, 0, 0.35),
                0 -1px 0 rgba(255, 247, 214, 0.52);
            opacity: 1;
            animation: titleFlow 12s linear infinite, titleBreath 4.8s ease-in-out infinite;
        }

        .title + .title {
            margin-top: 4px;
        }

        .loading-blink {
            animation: titleFlow 11s linear infinite, titleBreath 4.2s ease-in-out infinite;
        }

        .festive-text-box {
            width: min(96vw, 1300px);
            height: 80vh;
            height: calc(var(--vvh, 100vh) * 0.8);
            display: grid;
            grid-template-rows: auto auto;
            place-items: center;
            align-content: center;
            justify-items: center;
            gap: var(--title-gap-size);
            pointer-events: none;
            box-sizing: border-box;
        }

        .festive-text-box .title,
        .title.main,
        .title.subline {
            position: static !important;
            top: auto !important;
            left: auto !important;
            transform: none !important;
            margin: 0;
        }

        .title.main {
            font-size: var(--title-main-size);
            line-height: 1.08;
        }

        .title.subline {
            font-size: var(--title-sub-size);
            line-height: 1.08;
        }

        .fu-decoration {
            position: fixed;
            width: 1.5em;
            height: 1.5em;
            font-family: "STKaiti", "KaiTi", serif;
            font-size: clamp(34px, 6.8vw, 56px);
            color: #ffd700;
            background: #aa0000;
            border: 2px solid #ffd700;
            transform: rotate(45deg);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 0 10px rgba(255, 228, 136, 0.55),
                0 0 20px rgba(255, 190, 36, 0.45),
                inset 0 0 8px rgba(255, 234, 170, 0.35);
            filter: drop-shadow(0 0 8px rgba(255, 210, 90, 0.62));
        }

        .fu-decoration span {
            transform: rotate(-45deg);
            font-weight: 700;
            margin-top: 0.05em;
        }

        .fu-left {
            left: calc(env(safe-area-inset-left, 0px) + 18px);
            top: calc(env(safe-area-inset-top, 0px) + 18px);
        }

        .fu-right {
            right: calc(env(safe-area-inset-right, 0px) + 18px);
            top: calc(env(safe-area-inset-top, 0px) + 18px);
        }

        .horse-decoration {
            position: fixed;
            font-size: clamp(30px, 6vw, 48px);
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.55));
            opacity: 0.95;
        }

        .horse-left {
            left: calc(env(safe-area-inset-left, 0px) + 18px);
            bottom: calc(env(safe-area-inset-bottom, 0px) + 18px);
            transform: scaleX(-1);
        }

        .horse-right {
            right: calc(env(safe-area-inset-right, 0px) + 18px);
            bottom: calc(env(safe-area-inset-bottom, 0px) + 18px);
        }

        #debugToggle {
            display: none;
            position: absolute;
            right: 8px;
            top: 8px;
            z-index: 20;
            color: rgba(255, 255, 255, 0.84);
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.15);
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            user-select: none;
        }

        #debugPanel {
            position: absolute;
            right: 8px;
            top: 34px;
            z-index: 20;
            display: none;
            color: #d8eaff;
            font-size: 11px;
            line-height: 1.45;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.14);
            white-space: pre;
            pointer-events: none;
        }

        @keyframes titleFlow {
            to {
                background-position: 240% center;
            }
        }

        @keyframes titleBreath {
            0%, 100% {
                filter: brightness(1) saturate(1);
                opacity: 0.96;
            }
            50% {
                filter: brightness(1.08) saturate(1.06);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
<div id="app">
    <canvas id="canvas"></canvas>

    <div id="startOverlay">
        <div class="festive-wrap">
            <div class="fu-decoration fu-left"><span>Á¶è</span></div>
            <div class="fu-decoration fu-right"><span>Á¶è</span></div>
            <div class="horse-decoration horse-left">üêé</div>
            <div class="horse-decoration horse-right">üêé</div>

            <div class="festive-text-box">
                <p class="title main loading-title loading-blink">Êñ∞Âπ¥Âø´‰πê</p>
                <p class="title subline loading-title loading-blink">È©¨Âπ¥Â§ßÂêâ</p>
            </div>
        </div>
    </div>

    <div id="debugToggle">Debug: Off</div>
    <div id="debugPanel"></div>
</div>

<script>
/*
 * WeChat compatibility notes
 * 1) Canvas Êµ†Âë¨Â®áÈê¢?2DÈîõÊ∂òÂéõÁÅèÊøäÁòØ {alpha:false, desynchronized:true}ÈîõÂ±Ω„ÅëÁíê„É•Ê¥ñÈñ´‚Ç¨ÈèÖÓáÄ‚Ç¨?2DÈäÜ?
 * 2) Èç•ÂâßÂ¢ñÁí∫ÓàöÁ∑ûÊµ£Ë∑®Êï§ ./picture/x.jpgÈîõÂ≤ÄÊµâÁÄµÁ°ÖÁüæÂØ∞Âã´ÂΩ≤Èê©Â≠òÂ∏¥Èê¢„Ñ§Á∞¨ÈçöÂ±ΩÁÖô H5ÈäÜ?
 * 3) Èë∑ÓÅÑÂß©ÈçîÁä∫ÊµáÁÄπÂ±æÂûöÈçöÂ∫£Ê¥øÈé∫„É•Á¥ëÊøÆÂ¨∂Á¥±click/touch Êµ†Â∂ÑÁ∂îÊ∂ìÂìÑÂéπÊê¥Êõ°–ïÈçôÊàØÁ¥ùÊ∂ìÂ∂ÜÊ®âÁªÄËΩ∞Êç¢Êµ£Êõ†ÂÅ£ÈçëÁªòÂΩÅÁªÄÁÉòÊûÉÂ¶óÂ†õ‚Ç¨?
 * 4) resize Âß£ÂøîÓÇºÈçè?setTransform(1,0,0,1,0,0) Èçê?setTransform(dpr,0,0,dpr,0,0)ÈîõÂ≤Ñ‰º©ÈçèÂ∂áÁºâÈèÄÂâßÁñÆÁªâÓàò‚Ç¨?
 * 5) visibilitychange ÈçíÂõßÊÇóÈçôÁâàÊÆèÈçãÊªÑË¶ÜÈèåÊìÑÁ¥ùÈç•ÁÇ≤Â¢†ÈçôÁâà‰ªÆÊæ∂Â∂èÁ¥ùÈçëÂøìÁöØÂØ∞ÓÜª‰øäÈçöÂ∫°ÂΩ¥Èë∞Ê•ÉÊï∏ÈçúÂ±ΩÂ¥±Ê§§Ë£§‚Ç¨?
 */

(() => {
    const CONFIG = {
        // Force-60 mode: aggressive frame budget + staged particle spawning.
        force60Mode: true,
        imageCount: 15,
        imagePrefix: './picture/',
        backgroundMusicPath: './music/1.mp3',
        backgroundMusicVolume: 0.34,
        introHoldExtraMs: 0,

        phase: {
            photoShow: 'photoShow',
            finale: 'finale'
        },

        photoGapMs: [2200, 3200],
        photoTargetX: [0.20, 0.80],
        photoTargetY: [0.12, 0.40],
        photoRocketFlightSec: [0.8, 1.3],
        photoBurstRadiusHigh: [0.42, 0.52],
        photoBurstRadiusLow: [0.38, 0.48],
        photoStreakCountHigh: [460, 660],
        photoStreakCountLow: [360, 520],
        photoBurstExpandMs: [280, 380],
        photoBurstFadeMs: [1180, 1680],
        photoRevealShadowMs: [250, 450],
        photoRevealGrowMs: [450, 900],
        photoRevealHoldMs: [900, 1400],
        photoRevealFadeMs: [520, 820],

        streakSpeedFactor: [0.011, 0.020],
        streakWidth: [1.1, 2.8],
        streakLifeMs: [980, 1700],
        rocketTrailPerFrame: 2,

        shadowBlurStrong: [12, 20],
        shadowBlurWeak: [4, 8],
        shadowStrongFrames: 6,
        shadowTotalFrames: 12,
        centerFlashRadiusRatio: 0.24,

        photoDelayMs: [120, 200],
        photoFadeInMs: 250,
        photoHoldMs: 1450,
        photoFadeOutMs: 680,
        photoDiameterRatio: [0.56, 0.68],
        haloDiameterRatio: [0.92, 1.12],
        featherRatio: 0.18,

        miniGapHigh: [1200, 1800],
        miniGapLow: [1500, 2400],
        miniTargetX: [0.10, 0.90],
        miniTargetY: [0.12, 0.55],
        miniBurstCountHigh: [8, 14],
        miniBurstCountLow: [5, 10],

        finaleDuration: [12000, 18000],
        finaleVolleyInterval: [500, 900],
        finaleVolleyCountRange: [3, 7],
        finaleBurstRadius: [0.45, 0.75],
        finaleTargetX: [0.10, 0.90],
        finaleTargetY: [0.08, 0.55],
        finaleStreakCountHigh: [180, 260],
        finaleStreakCountLow: [120, 190],
        finaleColorPalette: ['#ffefb0', '#ffd676', '#ffb45e', '#ff944f', '#ff6c52', '#fff7df'],
        finaleEndMode: 'loop',
        finaleFadeoutMs: 5000,

        maxParticlesPhotoHigh: 560,
        maxParticlesPhotoLow: 420,
        maxParticlesFinaleHigh: 920,
        maxParticlesFinaleLow: 700,

        dtWindowSize: 30,
        lowEnterFps: 50,
        lowEnterDt: 20,
        highExitFps: 58,
        highExitDt: 16,
        highRecoverFrames: 80,

        dprDesktopCap: 1.8,
        dprHighCap: 1.45,
        dprLowCap: 1.15,

        clearAlphaHigh: 0.20,
        clearAlphaLow: 0.22,

        finaleDelayAfterLastBurst: [1500, 2500],
        finaleHoldMs: 15000,
        finaleVolleyIntervalForce60: [900, 1400],
        finaleVolleyCountRangeForce60: [1, 2],
        finaleBurstCountForce60: [34, 56],
        finaleParticleCapForce60: 150,
        finaleParticleFrameSkipForce60: 2,
        finaleGreetingText: 'XYTÊñ∞Âπ¥Âø´‰πêÔºÅÔºÅÔºÅ\nÈ©¨Âπ¥È°∫ÈÅÇÔºÅÔºÅÔºÅ'
    };

    const ua = navigator.userAgent || '';
    const isWeChat = /MicroMessenger/i.test(ua);
    const isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);

    const STATE = {
        phase: CONFIG.phase.photoShow,
        running: false,
        pausedByVisibility: false,
        lowPowerMode: false,
        assetsLoaded: false,
        loadRequested: false,

        dpr: 1,
        width: 0,
        height: 0,
        minDim: 0,

        fps: 60,
        avgDt: 16.6,
        recoverCounter: 0,
        qualityScale: 1,
        targetQualityScale: 1,
        nextFogAt: 0,

        mainImageIndex: 1,
        nextPhotoLaunchAt: 0,
        nextMiniLaunchAt: 0,

        finaleStartedAt: 0,
        finaleEndsAt: 0,
        nextFinaleVolleyAt: 0,
        finalePendingAt: 0,
        finaleFading: false,
        finaleFadeStart: 0,
        finaleGreetingShown: false,
        finaleGreetingStart: 0,
        startScheduled: false
    };

    const canvas = document.getElementById('canvas');
    const startOverlay = document.getElementById('startOverlay');
    const debugToggle = document.getElementById('debugToggle');
    const debugPanel = document.getElementById('debugPanel');
    const festiveTextBox = document.querySelector('.festive-text-box');
    const loadingTitles = document.querySelectorAll('.loading-title');
    const debugEnabled = new URLSearchParams(window.location.search).get('debug') === '1';

    let ctx = null;
    try {
        ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    } catch (e) {
        ctx = null;
    }
    if (!ctx) {
        try {
            ctx = canvas.getContext('2d', { alpha: false });
        } catch (e) {
            ctx = null;
        }
    }
    if (!ctx) ctx = canvas.getContext('2d');

    const images = new Array(CONFIG.imageCount + 1);
    const photoCache = new Array(CONFIG.imageCount + 1);

    let photoCacheBuildToken = 0;
    let photoCacheBuildRaf = 0;
    let resizeRaf = 0;

    const rockets = [];
    const bursts = [];
    const photoFireworks = [];

    const photoStage = {
        rocketUp: 'rocketUp',
        burstExpand: 'burstExpand',
        fallReveal: 'fallReveal'
    };

    const activeParticles = [];
    const particlePool = [];

    const dtRing = new Float32Array(CONFIG.dtWindowSize);
    let dtSum = 0;
    let dtCount = 0;
    let dtIndex = 0;

    let lastTs = 0;
    let rafId = 0;
    let debugOn = false;

    const drawState = {
        stroke: '',
        fill: ''
    };
    let bgMusic = null;
    let bgMusicStarted = false;

    const photoHaloCache = new Map();
    const photoRingCache = new Map();
    const flashSpriteCache = new Map();
    const finaleShellCache = new Map();
    const lineBatchMap = new Map();
    const fillBatchMap = new Map();
    const nightStars = [];
    const festiveDots = [];
    const spawnTasks = [];
    let spawnBudget = Infinity;
    let frameTick = 0;
    let startDelayTimer = 0;

    if (isMobile || isWeChat) {
        CONFIG.maxParticlesPhotoHigh = 460;
        CONFIG.maxParticlesPhotoLow = 320;
        CONFIG.maxParticlesFinaleHigh = 720;
        CONFIG.maxParticlesFinaleLow = 520;
        CONFIG.finaleStreakCountHigh = [140, 210];
        CONFIG.finaleStreakCountLow = [90, 150];
        CONFIG.dprHighCap = 1.25;
        CONFIG.dprLowCap = 1.05;
        CONFIG.photoStreakCountHigh = [420, 600];
        CONFIG.photoStreakCountLow = [320, 460];
    }

    function rand(min, max) {
        return min + Math.random() * (max - min);
    }

    function randInt(min, max) {
        return Math.floor(rand(min, max + 1));
    }

    function pick(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function nowMs() {
        return performance.now();
    }

    function initBackgroundMusic() {
        if (bgMusic) return bgMusic;
        const audio = new Audio(CONFIG.backgroundMusicPath);
        audio.loop = true;
        audio.preload = 'auto';
        audio.volume = CONFIG.backgroundMusicVolume;
        try {
            audio.playsInline = true;
            audio.setAttribute('playsinline', '');
            audio.setAttribute('webkit-playsinline', '');
        } catch (e) {
            // Ignore unsupported inline attributes.
        }
        bgMusic = audio;
        return bgMusic;
    }

    function playBackgroundMusic() {
        const audio = initBackgroundMusic();
        if (!audio) return;
        if (bgMusicStarted && !audio.paused) return;
        const p = audio.play();
        if (p && typeof p.then === 'function') {
            p.then(() => {
                bgMusicStarted = true;
            }).catch(() => {
                // Auto-play may be blocked until user gesture.
            });
            return;
        }
        bgMusicStarted = true;
    }

    function setTitleLoadingBlink(isLoading) {
        for (let i = 0; i < loadingTitles.length; i++) {
            if (isLoading) loadingTitles[i].classList.add('loading-blink');
            else loadingTitles[i].classList.remove('loading-blink');
        }
    }

    function currentSparkleChance() {
        if (CONFIG.force60Mode) {
            if (STATE.fps < 55) return 0.01;
            if (isMobile || isWeChat) return 0.06;
            return 0.12;
        }
        if (STATE.lowPowerMode) return STATE.fps < 48 ? 0 : 0.02;
        if (STATE.fps < 50) return 0.05;
        if (isMobile || isWeChat) return 0.18;
        return 0.32;
    }

    function currentParticleLimit() {
        if (CONFIG.force60Mode && STATE.phase === CONFIG.phase.finale) {
            let cap = CONFIG.finaleParticleCapForce60;
            if (STATE.fps < 50) cap = Math.round(cap * 0.85);
            if (STATE.fps < 44) cap = Math.round(cap * 0.72);
            if (STATE.fps < 38) cap = Math.round(cap * 0.58);
            return Math.max(72, cap);
        }
        const q = STATE.qualityScale;
        if (STATE.phase === CONFIG.phase.finale) {
            return Math.round(CONFIG.maxParticlesFinaleLow + (CONFIG.maxParticlesFinaleHigh - CONFIG.maxParticlesFinaleLow) * q);
        }
        return Math.round(CONFIG.maxParticlesPhotoLow + (CONFIG.maxParticlesPhotoHigh - CONFIG.maxParticlesPhotoLow) * q);
    }

    function currentSpawnBudget() {
        if (!CONFIG.force60Mode) return Infinity;
        let budget = (isMobile || isWeChat) ? 90 : 150;
        if (STATE.phase === CONFIG.phase.finale) budget += 35;
        if (STATE.fps < 58) budget = Math.round(budget * 0.82);
        if (STATE.fps < 52) budget = Math.round(budget * 0.68);
        if (STATE.fps < 46) budget = Math.round(budget * 0.52);
        if (STATE.fps < 40) budget = Math.round(budget * 0.38);
        if (STATE.lowPowerMode) budget = Math.round(budget * 0.86);
        return Math.max(24, budget);
    }

    function enqueueSpawnTask(count, maxPerFrame, emitOne) {
        if (count <= 0) return;
        if (CONFIG.force60Mode && spawnTasks.length > 56) {
            // Drop oldest queued workloads to protect frame time under extreme bursts.
            spawnTasks.shift();
        }
        spawnTasks.push({
            remaining: count,
            maxPerFrame: Math.max(1, maxPerFrame | 0),
            emitOne
        });
    }

    function processSpawnTasks() {
        if (spawnTasks.length === 0) return;
        for (let i = 0; i < spawnTasks.length;) {
            if (CONFIG.force60Mode && spawnBudget <= 0) break;
            const task = spawnTasks[i];
            let emitted = 0;
            const hardCap = CONFIG.force60Mode
                ? Math.min(task.maxPerFrame, task.remaining, spawnBudget)
                : Math.min(task.maxPerFrame, task.remaining);
            while (emitted < hardCap) {
                const p = getParticle();
                if (!p) break;
                task.emitOne(p);
                task.remaining -= 1;
                emitted += 1;
            }
            if (task.remaining <= 0 || emitted === 0) {
                if (task.remaining <= 0) {
                    spawnTasks.splice(i, 1);
                    continue;
                }
                i += 1;
                continue;
            }
            i += 1;
        }
    }

    function calcScaledRange(highRange, lowRange) {
        const q = STATE.qualityScale;
        const min = Math.round(lowRange[0] + (highRange[0] - lowRange[0]) * q);
        const max = Math.round(lowRange[1] + (highRange[1] - lowRange[1]) * q);
        return [Math.min(min, max), Math.max(min, max)];
    }

    function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
    }

    function quantize(v, step) {
        return Math.max(step, Math.round(v / step) * step);
    }

    function rebuildBackgroundDecor() {
        nightStars.length = 0;
        festiveDots.length = 0;

        const area = Math.max(1, STATE.width * STATE.height);
        let starCount = (isMobile || isWeChat) ? 85 : 170;
        starCount += Math.round(area / 24000);
        if (STATE.lowPowerMode) starCount = Math.round(starCount * 0.7);
        starCount = Math.max(70, Math.min(240, starCount));

        for (let i = 0; i < starCount; i++) {
            nightStars.push({
                x: Math.random() * STATE.width,
                y: Math.pow(Math.random(), 1.28) * STATE.height * 0.9,
                size: rand(0.8, 2.2),
                alpha: rand(0.28, 0.95),
                twinkle: rand(0.8, 2.4),
                phase: rand(0, Math.PI * 2),
                color: Math.random() < 0.8 ? '#cfe2ff' : '#e8f2ff'
            });
        }

        let dotCount = (isMobile || isWeChat) ? 28 : 56;
        dotCount += Math.round(area / 65000);
        if (STATE.lowPowerMode) dotCount = Math.round(dotCount * 0.75);
        dotCount = Math.max(24, Math.min(90, dotCount));

        const dotColors = ['#ffd56a', '#ffca5e', '#ffe3a8', '#ffb66d'];
        for (let i = 0; i < dotCount; i++) {
            festiveDots.push({
                x: Math.random() * STATE.width,
                y: Math.random() * STATE.height,
                size: rand(1.4, 3.8),
                alpha: rand(0.08, 0.24),
                twinkle: rand(0.6, 1.7),
                phase: rand(0, Math.PI * 2),
                color: pick(dotColors)
            });
        }
    }

    function drawPhotoShowBackground(now, clearA) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        const tintAlpha = clamp(clearA + 0.1, 0.18, 0.45);
        ctx.fillStyle = `rgba(3,9,30,${tintAlpha})`;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const sky = ctx.createLinearGradient(0, 0, 0, STATE.height);
        sky.addColorStop(0, 'rgba(10,24,68,0.42)');
        sky.addColorStop(0.55, 'rgba(8,20,58,0.30)');
        sky.addColorStop(1, 'rgba(4,10,30,0.22)');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const moonGlow = ctx.createRadialGradient(
            STATE.width * 0.78,
            STATE.height * 0.2,
            0,
            STATE.width * 0.78,
            STATE.height * 0.2,
            STATE.minDim * 0.32
        );
        moonGlow.addColorStop(0, 'rgba(112,152,255,0.20)');
        moonGlow.addColorStop(1, 'rgba(112,152,255,0)');
        ctx.fillStyle = moonGlow;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const t = now * 0.001;
        for (let i = 0; i < nightStars.length; i++) {
            const s = nightStars[i];
            const pulse = 0.58 + 0.42 * Math.sin(t * s.twinkle + s.phase);
            ctx.globalAlpha = s.alpha * pulse;
            ctx.fillStyle = s.color;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        }
        ctx.globalAlpha = 1;
    }

    function drawFinaleBackground(now, clearA) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        const tintAlpha = clamp(clearA + 0.06, 0.15, 0.36);
        ctx.fillStyle = `rgba(48,6,12,${tintAlpha})`;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const festive = ctx.createLinearGradient(0, 0, 0, STATE.height);
        festive.addColorStop(0, 'rgba(125,12,28,0.30)');
        festive.addColorStop(0.55, 'rgba(96,10,24,0.22)');
        festive.addColorStop(1, 'rgba(56,6,14,0.20)');
        ctx.fillStyle = festive;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const centerGlow = ctx.createRadialGradient(
            STATE.width * 0.5,
            STATE.height * 0.48,
            0,
            STATE.width * 0.5,
            STATE.height * 0.48,
            STATE.minDim * 0.6
        );
        centerGlow.addColorStop(0, 'rgba(255,82,82,0.14)');
        centerGlow.addColorStop(1, 'rgba(255,82,82,0)');
        ctx.fillStyle = centerGlow;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const t = now * 0.001;
        for (let i = 0; i < festiveDots.length; i++) {
            const d = festiveDots[i];
            const pulse = 0.65 + 0.35 * Math.sin(t * d.twinkle + d.phase);
            ctx.globalAlpha = d.alpha * pulse;
            ctx.fillStyle = d.color;
            ctx.fillRect(d.x, d.y, d.size, d.size);
        }
        ctx.globalAlpha = 1;
    }

    function drawFinaleGreeting(now) {
        if (!STATE.finaleGreetingShown) return;
        const text = CONFIG.finaleGreetingText;
        if (!text) return;
        const lines = String(text).split('\n').filter(Boolean);
        if (lines.length === 0) return;

        const pulse = 0.92 + Math.sin(now * 0.0038) * 0.08;
        const fontSize = Math.max(34, Math.min(72, Math.round(STATE.minDim * 0.075)));
        const lineGap = Math.round(fontSize * 0.34);
        const lineHeight = fontSize + lineGap;
        const totalHeight = lineHeight * (lines.length - 1);
        let y = STATE.height * 0.5 - totalHeight * 0.5;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `900 ${fontSize}px "PingFang SC", "Microsoft YaHei", sans-serif`;
        ctx.fillStyle = '#ffe7a8';
        ctx.shadowBlur = 20 * pulse;
        ctx.shadowColor = 'rgba(255,215,130,0.75)';
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], STATE.width * 0.5, y);
            y += lineHeight;
        }
        ctx.restore();
    }

    function drawPhaseBackground(now, clearA) {
        if (STATE.phase === CONFIG.phase.finale) {
            drawFinaleBackground(now, clearA);
            return;
        }
        drawPhotoShowBackground(now, clearA);
    }

    function clearRenderCaches() {
        photoHaloCache.clear();
        photoRingCache.clear();
        flashSpriteCache.clear();
        finaleShellCache.clear();
    }

    function getPhotoHaloSprite(photoDiameter, haloDiameter) {
        const pd = quantize(photoDiameter, 8);
        const hd = Math.max(pd + 8, quantize(haloDiameter, 8));
        const dprQ = STATE.lowPowerMode ? 1 : (Math.round(Math.min(1.35, STATE.dpr) * 10) / 10);
        const key = `${pd}_${hd}_${STATE.lowPowerMode ? 1 : 0}_${dprQ}`;
        const cached = photoHaloCache.get(key);
        if (cached) return cached;

        const spriteDpr = STATE.lowPowerMode ? 1 : Math.min(1.35, STATE.dpr);
        const drawSize = Math.ceil(hd * 1.35);
        const off = document.createElement('canvas');
        off.width = Math.max(2, Math.ceil(drawSize * spriteDpr));
        off.height = Math.max(2, Math.ceil(drawSize * spriteDpr));
        const g = off.getContext('2d');
        if (!g) return null;

        g.setTransform(1, 0, 0, 1, 0, 0);
        g.setTransform(spriteDpr, 0, 0, spriteDpr, 0, 0);

        const cx = drawSize * 0.5;
        const cy = drawSize * 0.5;
        const rOuter = hd * 0.5;
        const rInner = pd * 0.24;

        const halo = g.createRadialGradient(cx, cy, rInner, cx, cy, rOuter);
        halo.addColorStop(0, 'rgba(0,0,0,0.97)');
        halo.addColorStop(0.56, 'rgba(4,6,14,0.86)');
        halo.addColorStop(0.78, 'rgba(35,65,130,0.22)');
        halo.addColorStop(1, 'rgba(35,85,170,0)');
        g.fillStyle = halo;
        g.beginPath();
        g.arc(cx, cy, rOuter, 0, Math.PI * 2);
        g.fill();

        if (!STATE.lowPowerMode) {
            const edge = g.createRadialGradient(cx, cy, rOuter * 0.88, cx, cy, rOuter * 1.1);
            edge.addColorStop(0, 'rgba(170,220,255,0.08)');
            edge.addColorStop(1, 'rgba(170,220,255,0)');
            g.fillStyle = edge;
            g.beginPath();
            g.arc(cx, cy, rOuter * 1.1, 0, Math.PI * 2);
            g.fill();
        }

        const sprite = { canvas: off, size: drawSize };
        photoHaloCache.set(key, sprite);
        return sprite;
    }

    function getPhotoRingSprite(radius, countHint) {
        const rr = quantize(radius, CONFIG.force60Mode ? 20 : 12);
        const densityRaw = Math.max(320, countHint);
        const density = quantize(
            CONFIG.force60Mode ? Math.min(densityRaw, 460) : densityRaw,
            CONFIG.force60Mode ? 80 : 40
        );
        const dprQ = STATE.lowPowerMode ? 1 : (Math.round(Math.min(1.35, STATE.dpr) * 10) / 10);
        const key = `${rr}_${density}_${STATE.lowPowerMode ? 1 : 0}_${dprQ}`;
        const cached = photoRingCache.get(key);
        if (cached) return cached;

        const spriteDpr = STATE.lowPowerMode ? 1 : Math.min(1.35, STATE.dpr);
        const outerR = rr * 1.1;
        const drawSize = Math.ceil((outerR + rr * 0.42) * 2);
        const off = document.createElement('canvas');
        off.width = Math.max(2, Math.ceil(drawSize * spriteDpr));
        off.height = Math.max(2, Math.ceil(drawSize * spriteDpr));
        const g = off.getContext('2d');
        if (!g) return null;

        g.setTransform(1, 0, 0, 1, 0, 0);
        g.setTransform(spriteDpr, 0, 0, spriteDpr, 0, 0);

        const cx = drawSize * 0.5;
        const cy = drawSize * 0.5;
        g.translate(cx, cy);
        g.globalCompositeOperation = 'lighter';

        const streakTotal = STATE.lowPowerMode
            ? Math.max(260, Math.round(density * (CONFIG.force60Mode ? 0.74 : 0.88)))
            : Math.round(density * (CONFIG.force60Mode ? 0.86 : 1.05));
        const ringColors = [
            'rgba(110,228,255,0.95)',
            'rgba(125,182,255,0.92)',
            'rgba(157,145,255,0.92)',
            'rgba(210,150,255,0.92)',
            'rgba(255,190,245,0.88)'
        ];
        for (let i = 0; i < streakTotal; i++) {
            const a = (i / streakTotal) * Math.PI * 2 + rand(-0.016, 0.016);
            const inner = rr * rand(0.10, 0.22);
            const len = rr * rand(0.82, 1.08);
            const lw = rand(1.0, 2.6) * (STATE.lowPowerMode ? 0.95 : 1.15);
            g.globalAlpha = rand(0.36, 0.9);
            g.strokeStyle = pick(ringColors);
            g.lineWidth = lw;
            g.beginPath();
            g.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
            g.lineTo(Math.cos(a) * len, Math.sin(a) * len);
            g.stroke();
        }

        const headCount = STATE.lowPowerMode
            ? Math.max(130, Math.floor(streakTotal * (CONFIG.force60Mode ? 0.42 : 0.54)))
            : Math.max(170, Math.floor(streakTotal * (CONFIG.force60Mode ? 0.50 : 0.72)));
        const headColors = [
            'rgba(200,245,255,0.95)',
            'rgba(220,210,255,0.95)',
            'rgba(255,220,255,0.92)',
            'rgba(255,245,255,0.95)'
        ];
        for (let i = 0; i < headCount; i++) {
            const a = rand(0, Math.PI * 2);
            const r = rr * rand(0.88, 1.1);
            const dot = STATE.lowPowerMode ? rand(1.05, 1.9) : rand(1.2, 2.7);
            g.globalAlpha = rand(0.45, 0.98);
            g.fillStyle = pick(headColors);
            g.beginPath();
            g.arc(Math.cos(a) * r, Math.sin(a) * r, dot, 0, Math.PI * 2);
            g.fill();
        }

        const glow = g.createRadialGradient(0, 0, rr * 0.58, 0, 0, rr * 1.28);
        glow.addColorStop(0, 'rgba(120,150,255,0)');
        glow.addColorStop(0.74, STATE.lowPowerMode ? 'rgba(132,165,255,0.10)' : 'rgba(132,165,255,0.16)');
        glow.addColorStop(1, 'rgba(132,165,255,0)');
        g.fillStyle = glow;
        g.beginPath();
        g.arc(0, 0, rr * 1.28, 0, Math.PI * 2);
        g.fill();

        // Core flash is pre-composited into burst sprite to avoid per-frame gradient cost.
        const core = g.createRadialGradient(0, 0, 0, 0, 0, rr * 0.34);
        core.addColorStop(0, 'rgba(255,255,255,0.98)');
        core.addColorStop(0.24, 'rgba(240,248,255,0.86)');
        core.addColorStop(1, 'rgba(240,248,255,0)');
        g.fillStyle = core;
        g.beginPath();
        g.arc(0, 0, rr * 0.34, 0, Math.PI * 2);
        g.fill();

        const sprite = { canvas: off, size: drawSize };
        photoRingCache.set(key, sprite);
        return sprite;
    }

    function getFinaleShellSprite(radius) {
        const rr = quantize(radius, CONFIG.force60Mode ? 20 : 14);
        const dprQ = STATE.lowPowerMode ? 1 : (Math.round(Math.min(1.25, STATE.dpr) * 10) / 10);
        const key = `${rr}_${STATE.lowPowerMode ? 1 : 0}_${dprQ}`;
        const cached = finaleShellCache.get(key);
        if (cached) return cached;

        const spriteDpr = STATE.lowPowerMode ? 1 : Math.min(1.25, STATE.dpr);
        const drawSize = Math.ceil(rr * 2.5);
        const off = document.createElement('canvas');
        off.width = Math.max(2, Math.ceil(drawSize * spriteDpr));
        off.height = Math.max(2, Math.ceil(drawSize * spriteDpr));
        const g = off.getContext('2d');
        if (!g) return null;

        g.setTransform(1, 0, 0, 1, 0, 0);
        g.setTransform(spriteDpr, 0, 0, spriteDpr, 0, 0);
        const cx = drawSize * 0.5;
        const cy = drawSize * 0.5;
        g.translate(cx, cy);
        g.globalCompositeOperation = 'lighter';

        const spokeCount = STATE.lowPowerMode
            ? (CONFIG.force60Mode ? 54 : 84)
            : (CONFIG.force60Mode ? 72 : 120);
        const spokeColors = [
            'rgba(255,236,176,0.96)',
            'rgba(255,212,142,0.94)',
            'rgba(255,186,108,0.92)',
            'rgba(255,162,96,0.90)'
        ];
        for (let i = 0; i < spokeCount; i++) {
            const a = (i / spokeCount) * Math.PI * 2 + rand(-0.011, 0.011);
            const inner = rr * rand(0.03, 0.12);
            const len = rr * rand(0.78, 1.08);
            g.globalAlpha = rand(0.48, 0.96);
            g.strokeStyle = pick(spokeColors);
            g.lineWidth = rand(1.2, 2.8) * (STATE.lowPowerMode ? 0.86 : 1);
            g.beginPath();
            g.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
            g.lineTo(Math.cos(a) * len, Math.sin(a) * len);
            g.stroke();
        }

        const tipCount = STATE.lowPowerMode
            ? Math.max(58, Math.floor(spokeCount * 0.5))
            : Math.max(84, Math.floor(spokeCount * 0.66));
        for (let i = 0; i < tipCount; i++) {
            const a = rand(0, Math.PI * 2);
            const r = rr * rand(0.82, 1.1);
            const dot = STATE.lowPowerMode ? rand(0.9, 1.6) : rand(1.1, 2.0);
            g.globalAlpha = rand(0.42, 0.95);
            g.fillStyle = 'rgba(255,240,198,0.94)';
            g.beginPath();
            g.arc(Math.cos(a) * r, Math.sin(a) * r, dot, 0, Math.PI * 2);
            g.fill();
        }

        const glow = g.createRadialGradient(0, 0, rr * 0.35, 0, 0, rr * 1.22);
        glow.addColorStop(0, 'rgba(255,185,112,0.12)');
        glow.addColorStop(0.72, STATE.lowPowerMode ? 'rgba(255,135,80,0.09)' : 'rgba(255,135,80,0.14)');
        glow.addColorStop(1, 'rgba(255,135,80,0)');
        g.fillStyle = glow;
        g.beginPath();
        g.arc(0, 0, rr * 1.22, 0, Math.PI * 2);
        g.fill();

        const core = g.createRadialGradient(0, 0, 0, 0, 0, rr * 0.26);
        core.addColorStop(0, 'rgba(255,246,222,0.98)');
        core.addColorStop(0.34, 'rgba(255,220,166,0.68)');
        core.addColorStop(1, 'rgba(255,190,140,0)');
        g.fillStyle = core;
        g.beginPath();
        g.arc(0, 0, rr * 0.26, 0, Math.PI * 2);
        g.fill();

        const sprite = { canvas: off, size: drawSize };
        finaleShellCache.set(key, sprite);
        return sprite;
    }

    function getFlashSprite(type, radius, liteMode) {
        const base = Math.max(14, quantize(radius * CONFIG.centerFlashRadiusRatio, 4));
        const f = liteMode ? 0.54 : (type === 'finale' ? 0.78 : 1);
        const rr = quantize(base * f, 2);
        const dprQ = STATE.lowPowerMode ? 1 : (Math.round(Math.min(1.25, STATE.dpr) * 10) / 10);
        const key = `${type}_${liteMode ? 1 : 0}_${rr}_${STATE.lowPowerMode ? 1 : 0}_${dprQ}`;
        const cached = flashSpriteCache.get(key);
        if (cached) return cached;

        const spriteDpr = STATE.lowPowerMode ? 1 : Math.min(1.25, STATE.dpr);
        const drawSize = Math.ceil(rr * 2 + 6);
        const off = document.createElement('canvas');
        off.width = Math.max(2, Math.ceil(drawSize * spriteDpr));
        off.height = Math.max(2, Math.ceil(drawSize * spriteDpr));
        const g = off.getContext('2d');
        if (!g) return null;

        g.setTransform(1, 0, 0, 1, 0, 0);
        g.setTransform(spriteDpr, 0, 0, spriteDpr, 0, 0);

        const cx = drawSize * 0.5;
        const cy = drawSize * 0.5;
        const grad = g.createRadialGradient(cx, cy, 0, cx, cy, rr);
        if (type === 'finale') {
            grad.addColorStop(0, 'rgba(255,252,240,0.96)');
            grad.addColorStop(0.34, 'rgba(255,228,168,0.58)');
            grad.addColorStop(1, 'rgba(255,210,145,0)');
        } else {
            grad.addColorStop(0, 'rgba(255,255,255,0.98)');
            grad.addColorStop(0.32, 'rgba(210,235,255,0.6)');
            grad.addColorStop(1, 'rgba(210,235,255,0)');
        }
        g.fillStyle = grad;
        g.beginPath();
        g.arc(cx, cy, rr, 0, Math.PI * 2);
        g.fill();

        const sprite = { canvas: off, size: drawSize };
        flashSpriteCache.set(key, sprite);
        return sprite;
    }

    function drawParticlesBatched(g) {
        if (activeParticles.length === 0) return;

        const usedLine = [];
        const usedFill = [];
        const sparkleChance = currentSparkleChance();
        const allowSparkle = sparkleChance > 0 && !(STATE.lowPowerMode && STATE.fps < 56);

        for (let i = 0; i < activeParticles.length; i++) {
            const p = activeParticles[i];
            const a = p.life > 0 ? (p.life / p.maxLife) : 0;
            if (a <= 0) continue;

            const alpha = clamp(Math.round(a * 6) / 6, 0.12, 1);
            if (p.kind === 'trail' || p.kind === 'dust') {
                const size = Math.max(0.8, Math.round(p.width * 4) / 4);
                const key = `${p.color}|${alpha.toFixed(2)}|${size.toFixed(2)}`;
                let group = fillBatchMap.get(key);
                if (!group) {
                    group = { color: p.color, alpha, size, data: [], active: false };
                    fillBatchMap.set(key, group);
                }
                if (!group.active) {
                    group.active = true;
                    group.data.length = 0;
                    usedFill.push(group);
                }
                group.data.push(p.x, p.y);
                continue;
            }

            const width = Math.max(0.8, Math.round(p.width * 5) / 5);
            const key = `${p.color}|${alpha.toFixed(2)}|${width.toFixed(2)}`;
            let group = lineBatchMap.get(key);
            if (!group) {
                group = { color: p.color, alpha, width, data: [], active: false };
                lineBatchMap.set(key, group);
            }
            if (!group.active) {
                group.active = true;
                group.data.length = 0;
                usedLine.push(group);
            }
            group.data.push(p.px, p.py, p.x, p.y);

            if (allowSparkle && p.sparkle && a < 0.62 && Math.random() < sparkleChance) {
                const s = p.kind === 'main' ? (STATE.lowPowerMode ? 1.4 : 2.1) : 1.2;
                const sa = clamp(alpha * 1.2, 0.16, 1);
                const skey = `${p.sparkColor}|${sa.toFixed(2)}|${s.toFixed(2)}`;
                let sgroup = fillBatchMap.get(skey);
                if (!sgroup) {
                    sgroup = { color: p.sparkColor, alpha: sa, size: s, data: [], active: false };
                    fillBatchMap.set(skey, sgroup);
                }
                if (!sgroup.active) {
                    sgroup.active = true;
                    sgroup.data.length = 0;
                    usedFill.push(sgroup);
                }
                sgroup.data.push(p.x, p.y);
            }
        }

        for (let i = 0; i < usedLine.length; i++) {
            const group = usedLine[i];
            g.globalAlpha = group.alpha;
            if (drawState.stroke !== group.color) {
                g.strokeStyle = group.color;
                drawState.stroke = group.color;
            }
            g.lineWidth = group.width;
            g.beginPath();
            const arr = group.data;
            for (let j = 0; j < arr.length; j += 4) {
                g.moveTo(arr[j], arr[j + 1]);
                g.lineTo(arr[j + 2], arr[j + 3]);
            }
            g.stroke();
            group.active = false;
        }

        for (let i = 0; i < usedFill.length; i++) {
            const group = usedFill[i];
            g.globalAlpha = group.alpha;
            if (drawState.fill !== group.color) {
                g.fillStyle = group.color;
                drawState.fill = group.color;
            }
            const arr = group.data;
            const s = group.size;
            for (let j = 0; j < arr.length; j += 2) {
                g.fillRect(arr[j] - s * 0.5, arr[j + 1] - s * 0.5, s, s);
            }
            group.active = false;
        }
    }

    class Particle {
        constructor() {
            this.active = false;
        }

        reset(opt) {
            this.x = opt.x;
            this.y = opt.y;
            this.px = opt.x;
            this.py = opt.y;
            this.vx = opt.vx;
            this.vy = opt.vy;
            this.gravity = opt.gravity || 0;
            this.drag = opt.drag || 1;
            this.life = opt.life;
            this.maxLife = opt.life;
            this.color = opt.color;
            this.width = opt.width || 1;
            this.kind = opt.kind || 'main';
            this.sparkle = !!opt.sparkle;
            this.sparkColor = opt.sparkColor || '#fff';
            this.active = true;
        }

        update(dt) {
            const dts = dt / 1000;
            this.px = this.x;
            this.py = this.y;
            this.x += this.vx * dts;
            this.y += this.vy * dts;

            this.vy += this.gravity * dts;
            const dragPow = Math.pow(this.drag, dts * 60);
            this.vx *= dragPow;
            this.vy *= dragPow;

            this.life -= dt;
            if (this.life <= 0) this.active = false;
        }

        draw(g) {
            const a = Math.max(0, this.life / this.maxLife);
            if (a <= 0) return;

            if (this.kind === 'trail' || this.kind === 'dust') {
                g.globalAlpha = a;
                if (drawState.fill !== this.color) {
                    g.fillStyle = this.color;
                    drawState.fill = this.color;
                }
                const s = this.width;
                g.fillRect(this.x - s * 0.5, this.y - s * 0.5, s, s);
                return;
            }

            g.globalAlpha = a;
            if (drawState.stroke !== this.color) {
                g.strokeStyle = this.color;
                drawState.stroke = this.color;
            }
            g.lineWidth = this.width;
            g.beginPath();
            g.moveTo(this.px, this.py);
            g.lineTo(this.x, this.y);
            g.stroke();

            if (this.sparkle && a < 0.55 && Math.random() < currentSparkleChance()) {
                if (drawState.fill !== this.sparkColor) {
                    g.fillStyle = this.sparkColor;
                    drawState.fill = this.sparkColor;
                }
                const s = this.kind === 'main' ? 2.0 : 1.4;
                g.fillRect(this.x - s * 0.5, this.y - s * 0.5, s, s);
            }
        }
    }

    function getParticle() {
        if (activeParticles.length >= currentParticleLimit()) return null;
        if (CONFIG.force60Mode && spawnBudget <= 0) return null;
        let p = particlePool.pop();
        if (!p) p = new Particle();
        activeParticles.push(p);
        if (CONFIG.force60Mode) spawnBudget -= 1;
        return p;
    }

    function recycleParticle(i) {
        const p = activeParticles[i];
        const last = activeParticles.pop();
        if (i < activeParticles.length) activeParticles[i] = last;
        p.active = false;
        particlePool.push(p);
    }

    class Rocket {
        constructor(opt) {
            this.type = opt.type;
            this.imageIndex = opt.imageIndex || 0;
            this.x = opt.startX;
            this.y = STATE.height + rand(6, 18);
            this.tx = opt.tx;
            this.ty = opt.ty;
            this.done = false;
            this.jitterT = rand(0, 999);

            this.vy = -rand(560, 760);
            const flight = Math.max(0.8, (this.y - this.ty) / Math.abs(this.vy));
            this.vx = (this.tx - this.x) / flight;
            this.gravity = rand(320, 460);
        }

        update(dt) {
            const dts = dt / 1000;
            this.jitterT += dts;
            const side = Math.sin(this.jitterT * 16) * 0.7;

            this.x += (this.vx + side) * dts;
            this.y += this.vy * dts;
            this.vy += this.gravity * dts;

            let trailCount;
            if (this.type === 'mini') {
                if (STATE.lowPowerMode || STATE.fps < 45) trailCount = 0;
                else if (STATE.fps < 55) trailCount = 1;
                else trailCount = 1;
            } else {
                if (STATE.lowPowerMode || STATE.fps < 45) trailCount = 0;
                else if (STATE.fps < 55) trailCount = 1;
                else trailCount = 2;
            }

            const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
            trailCount = Math.min(trailCount, budget);

            for (let i = 0; i < trailCount; i++) {
                const p = getParticle();
                if (!p) break;
                p.reset({
                    x: this.x + rand(-2, 2),
                    y: this.y + rand(-2, 2),
                    vx: rand(-18, 18),
                    vy: rand(24, 104),
                    gravity: rand(120, 220),
                    drag: 0.989,
                    life: rand(160, 300),
                    color: '#ffffff',
                    width: rand(1.0, 1.8),
                    kind: 'trail'
                });
            }

            if (this.vy > -15 || this.y <= this.ty) {
                this.done = true;
                onRocketExplode(this);
            }
        }

        draw(g) {
            g.save();
            g.globalCompositeOperation = 'lighter';
            g.globalAlpha = 0.95;
            g.fillStyle = '#fff';
            g.fillRect(this.x - 1.5, this.y - 1.5, 3, 3);
            g.restore();
        }
    }

    class PhotoFirework {
        constructor(opt) {
            this.imageIndex = opt.imageIndex;
            this.isLast = !!opt.isLast;

            this.stage = photoStage.rocketUp;
            this.stageElapsed = 0;
            this.burstElapsed = 0;
            this.dead = false;

            this.tx = opt.tx;
            this.ty = opt.ty;
            this.x = opt.startX;
            this.y = STATE.height + rand(8, 18);
            this.jitterT = rand(0, 1000);
            this.jitterAmp = rand(0.55, 1.2);

            const distance = Math.hypot(this.tx - this.x, this.ty - this.y);
            const speed = rand(760, 980);
            const flightSecByDistance = distance / Math.max(1, speed);
            const flightSec = clamp(
                flightSecByDistance,
                CONFIG.photoRocketFlightSec[0],
                CONFIG.photoRocketFlightSec[1]
            );
            this.rocketLifeMs = flightSec * 1000;
            this.gravity = rand(280, 420);
            this.vx = (this.tx - this.x) / flightSec;
            this.vy = (this.ty - this.y - 0.5 * this.gravity * flightSec * flightSec) / flightSec;

            this.radius = chooseBurstRadius('photo');
            this.streakCount = countForBurst('photo');
            this.photoDiameter = this.radius * rand(CONFIG.photoDiameterRatio[0], CONFIG.photoDiameterRatio[1]);
            this.haloDiameter = this.radius * rand(CONFIG.haloDiameterRatio[0], CONFIG.haloDiameterRatio[1]);
            this.palette = paletteFor('photo');

            this.burstSprite = getPhotoRingSprite(this.radius, this.streakCount);
            this.flashSprite = getFlashSprite('photo', this.radius, false);
            this.haloSprite = getPhotoHaloSprite(this.photoDiameter, this.haloDiameter);

            this.rotation = rand(0, Math.PI * 2);
            this.spin = rand(-0.24, 0.24) * (STATE.lowPowerMode ? 0.6 : 1);
            this.burstExpandMs = rand(CONFIG.photoBurstExpandMs[0], CONFIG.photoBurstExpandMs[1]);
            this.burstFadeMs = rand(CONFIG.photoBurstFadeMs[0], CONFIG.photoBurstFadeMs[1]);

            this.revealShadowMs = rand(CONFIG.photoRevealShadowMs[0], CONFIG.photoRevealShadowMs[1]);
            this.revealGrowMs = rand(
                Math.max(this.revealShadowMs + 120, CONFIG.photoRevealGrowMs[0]),
                CONFIG.photoRevealGrowMs[1]
            );
            this.revealHoldMs = rand(
                Math.max(this.revealGrowMs + 180, CONFIG.photoRevealHoldMs[0]),
                CONFIG.photoRevealHoldMs[1]
            );
            this.revealOutMs = this.revealHoldMs + rand(CONFIG.photoRevealFadeMs[0], CONFIG.photoRevealFadeMs[1]);
        }

        spawnRocketTrail() {
            let trailCount = CONFIG.rocketTrailPerFrame;
            if (STATE.lowPowerMode || STATE.fps < 48) trailCount = 1;
            else if (STATE.fps < 56) trailCount = 2;
            else trailCount = 3;

            const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
            trailCount = Math.min(trailCount, budget);

            for (let i = 0; i < trailCount; i++) {
                const p = getParticle();
                if (!p) break;
                p.reset({
                    x: this.x + rand(-1.8, 1.8),
                    y: this.y + rand(-1.8, 1.8),
                    vx: rand(-26, 26),
                    vy: rand(52, 145),
                    gravity: rand(130, 240),
                    drag: 0.987,
                    life: rand(190, 360),
                    color: '#ffe8bf',
                    width: rand(1.0, 1.9),
                    kind: 'trail'
                });
            }

            if (!STATE.lowPowerMode && Math.random() < 0.32) {
                const sp = getParticle();
                if (sp) {
                    sp.reset({
                        x: this.x + rand(-1.2, 1.2),
                        y: this.y + rand(-1.2, 1.2),
                        vx: rand(-38, 38),
                        vy: rand(30, 116),
                        gravity: rand(140, 220),
                        drag: 0.985,
                        life: rand(110, 180),
                        color: '#fffdf0',
                        width: rand(1.0, 1.5),
                        kind: 'trail'
                    });
                }
            }
        }

        spawnFallingParticles() {
            const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
            if (budget <= 0) return;

            let wanted = Math.round(this.streakCount * (STATE.lowPowerMode ? 0.18 : 0.28));
            if (isMobile || isWeChat) wanted = Math.round(wanted * 0.86);
            if (STATE.fps < 50) wanted = Math.round(wanted * 0.82);
            const count = Math.min(budget, Math.max(120, wanted));

            const mainEmit = (p) => {
                const a = rand(0, Math.PI * 2);
                const speed = this.radius * rand(0.013, 0.024) * 60;
                p.reset({
                    x: this.tx,
                    y: this.ty,
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed,
                    gravity: rand(180, 300),
                    drag: rand(0.982, 0.991),
                    life: rand(980, 1780),
                    color: pick(this.palette),
                    width: rand(1.0, 2.4),
                    kind: 'main',
                    sparkle: !STATE.lowPowerMode,
                    sparkColor: '#fef8ee'
                });
            };
            if (CONFIG.force60Mode) {
                enqueueSpawnTask(count, Math.max(18, Math.floor(count * 0.34)), mainEmit);
            } else {
                for (let i = 0; i < count; i++) {
                    const p = getParticle();
                    if (!p) break;
                    mainEmit(p);
                }
            }

            if (STATE.lowPowerMode) return;
            const tipCount = Math.max(40, Math.min(140, Math.floor(count * 0.32)));
            const tipEmit = (p) => {
                const a = rand(0, Math.PI * 2);
                const speed = this.radius * rand(0.015, 0.026) * 60;
                p.reset({
                    x: this.tx,
                    y: this.ty,
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed,
                    gravity: rand(220, 320),
                    drag: rand(0.981, 0.988),
                    life: rand(720, 1220),
                    color: '#fff9f0',
                    width: rand(0.9, 1.5),
                    kind: 'trail'
                });
            };
            if (CONFIG.force60Mode) {
                enqueueSpawnTask(tipCount, Math.max(10, Math.floor(tipCount * 0.5)), tipEmit);
            } else {
                for (let i = 0; i < tipCount; i++) {
                    const p = getParticle();
                    if (!p) break;
                    tipEmit(p);
                }
            }
        }

        enterBurst() {
            this.stage = photoStage.burstExpand;
            this.stageElapsed = 0;
            this.burstElapsed = 0;
            this.x = this.tx;
            this.y = this.ty;
            this.spawnFallingParticles();
            if (this.isLast && STATE.finalePendingAt === 0) {
                STATE.finalePendingAt = nowMs() + rand(CONFIG.finaleDelayAfterLastBurst[0], CONFIG.finaleDelayAfterLastBurst[1]);
            }
        }

        update(dt) {
            const dts = dt / 1000;
            if (this.stage === photoStage.rocketUp) {
                this.stageElapsed += dt;
                this.jitterT += dts;
                const side = Math.sin(this.jitterT * 13) * this.jitterAmp;
                this.x += (this.vx + side) * dts;
                this.y += this.vy * dts;
                this.vy += this.gravity * dts;
                this.spawnRocketTrail();

                if (this.stageElapsed >= this.rocketLifeMs || this.y <= this.ty) {
                    this.enterBurst();
                }
                return;
            }

            this.stageElapsed += dt;
            this.burstElapsed += dt;

            if (this.stage === photoStage.burstExpand && this.stageElapsed >= this.burstExpandMs) {
                this.stage = photoStage.fallReveal;
                this.stageElapsed = 0;
            }

            if (this.burstElapsed > this.revealOutMs + 800) {
                this.dead = true;
            }
        }

        drawRocket(g) {
            if (this.stage !== photoStage.rocketUp) return;
            g.save();
            g.globalCompositeOperation = 'lighter';
            g.globalAlpha = 0.96;
            g.fillStyle = '#fff9ef';
            g.fillRect(this.x - 1.8, this.y - 1.8, 3.6, 3.6);
            g.restore();
        }

        drawBurst(g, liteMode) {
            if (this.stage === photoStage.rocketUp || !this.burstSprite) return;

            let scale;
            if (this.stage === photoStage.burstExpand) {
                const p = clamp(this.stageElapsed / this.burstExpandMs, 0, 1);
                scale = 0.22 + (1 - Math.pow(1 - p, 2.4)) * 0.96;
            } else {
                const p = clamp((this.burstElapsed - this.burstExpandMs) / 900, 0, 1);
                scale = 1.02 + p * 0.18;
            }

            const fade = this.stage === photoStage.burstExpand
                ? 1
                : clamp(1 - ((this.burstElapsed - this.burstExpandMs) / this.burstFadeMs), 0, 1);
            const alpha = fade * (STATE.lowPowerMode ? 0.92 : 1);
            if (alpha <= 0.01) return;

            const rot = this.rotation + this.spin * (this.burstElapsed * 0.001);
            const size = this.burstSprite.size * scale;
            g.save();
            g.translate(this.tx, this.ty);
            g.rotate(rot);
            g.globalAlpha = alpha;
            g.drawImage(this.burstSprite.canvas, -size * 0.5, -size * 0.5, size, size);
            if (!liteMode && !STATE.lowPowerMode) {
                const bloom = size * 1.08;
                g.globalAlpha = alpha * 0.32;
                g.drawImage(this.burstSprite.canvas, -bloom * 0.5, -bloom * 0.5, bloom, bloom);
            }
            g.restore();
        }

        drawCenterFlash(g, liteMode) {
            if (this.stage === photoStage.rocketUp) return;
            if (this.burstElapsed > 120 || !this.flashSprite) return;
            const p = this.burstElapsed / 120;
            const alpha = (1 - p) * (liteMode ? 0.75 : 1);
            if (alpha <= 0.01) return;
            const scale = 0.92 + p * 0.56;
            const size = this.flashSprite.size * scale;
            g.globalAlpha = alpha;
            g.drawImage(this.flashSprite.canvas, this.tx - size * 0.5, this.ty - size * 0.5, size, size);
        }

        drawPhoto(g) {
            if (this.stage !== photoStage.fallReveal) return;
            const img = photoCache[this.imageIndex];
            if (!img) return;

            const t = this.burstElapsed;
            if (t < this.revealShadowMs) return;

            let alpha = 0;
            let scale = 0.92;
            if (t < this.revealGrowMs) {
                const p = (t - this.revealShadowMs) / Math.max(1, this.revealGrowMs - this.revealShadowMs);
                alpha = 0.04 + (1 - Math.pow(1 - p, 2.2)) * 0.96;
                scale = 0.92 + p * 0.16;
            } else if (t < this.revealHoldMs) {
                alpha = 1;
                scale = 1.08 + Math.sin((t - this.revealGrowMs) * 0.009) * 0.012;
            } else if (t < this.revealOutMs) {
                const p = (t - this.revealHoldMs) / Math.max(1, this.revealOutMs - this.revealHoldMs);
                alpha = 1 - p;
                scale = 1.08 + p * 0.06;
            } else {
                return;
            }

            if (this.haloSprite) {
                const haloScale = scale * (1.03 + Math.sin(t * 0.006) * 0.02);
                const haloSize = this.haloSprite.size * haloScale;
                g.globalCompositeOperation = 'source-over';
                g.globalAlpha = alpha * (STATE.lowPowerMode ? 0.88 : 0.98);
                g.drawImage(
                    this.haloSprite.canvas,
                    this.tx - haloSize * 0.5,
                    this.ty - haloSize * 0.5,
                    haloSize,
                    haloSize
                );
            }

            const size = this.photoDiameter * scale;
            g.globalCompositeOperation = 'source-over';
            g.globalAlpha = alpha;
            g.drawImage(img, this.tx - size * 0.5, this.ty - size * 0.5, size, size);
        }
    }

    class Burst {
        constructor(opt) {
            this.type = opt.type;
            this.x = opt.x;
            this.y = opt.y;
            this.imageIndex = opt.imageIndex || 0;
            this.ageMs = 0;
            this.frameAge = 0;
            this.dead = false;

            this.radius = opt.radius;
            this.streakCount = opt.count || 0;
            this.photoDiameter = this.radius * rand(CONFIG.photoDiameterRatio[0], CONFIG.photoDiameterRatio[1]);
            this.haloDiameter = this.radius * rand(CONFIG.haloDiameterRatio[0], CONFIG.haloDiameterRatio[1]);

            this.blurStrong = rand(CONFIG.shadowBlurStrong[0], CONFIG.shadowBlurStrong[1]);
            this.blurWeak = rand(CONFIG.shadowBlurWeak[0], CONFIG.shadowBlurWeak[1]);

            this.photoRingSprite = null;
            this.finaleShellSprite = null;
            this.ringLifeMs = 0;
            this.ringScaleStart = 1;
            this.ringScaleEnd = 1;
            this.ringAlpha = 1;
            this.ringRotation = rand(0, Math.PI * 2);
            this.ringSpin = 0;

            if (this.type === 'photo') {
                this.photoRingSprite = getPhotoRingSprite(this.radius, this.streakCount);
                this.ringLifeMs = rand(1200, 1720);
                this.ringScaleStart = rand(0.72, 0.82);
                this.ringScaleEnd = rand(1.02, 1.12);
                this.ringAlpha = rand(0.92, 1.08);
                this.ringSpin = rand(-0.20, 0.20) * (STATE.lowPowerMode ? 0.55 : 1);
            } else if (this.type === 'finale') {
                this.finaleShellSprite = getFinaleShellSprite(this.radius);
                this.ringLifeMs = rand(880, 1320);
                this.ringScaleStart = rand(0.48, 0.58);
                this.ringScaleEnd = rand(1.06, 1.18);
                this.ringAlpha = rand(0.9, 1.06);
                this.ringSpin = rand(-0.09, 0.09) * (STATE.lowPowerMode ? 0.5 : 1);
            }

            this.spawnParticles(opt);
        }

        spawnParticles(opt) {
            const colors = opt.palette;
            const count = opt.count;

            if (this.type === 'photo') {
                const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
                if (budget <= 0) return;
                const wanted = Math.max(46, Math.round((count || 420) * (STATE.lowPowerMode ? 0.11 : 0.16)));
                const sparkCount = Math.min(wanted, budget);

                const photoEmit = (p) => {
                    const a = rand(0, Math.PI * 2);
                    const speed = this.radius * rand(0.013, 0.024) * 60;
                    p.reset({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(a) * speed,
                        vy: Math.sin(a) * speed,
                        gravity: rand(30, 82),
                        drag: rand(0.982, 0.990),
                        life: rand(760, 1280),
                        color: pick(colors),
                        width: rand(1.0, 2.3),
                        kind: 'main',
                        sparkle: !STATE.lowPowerMode,
                        sparkColor: '#eef8ff'
                    });
                };
                if (CONFIG.force60Mode) {
                    enqueueSpawnTask(sparkCount, Math.max(14, Math.floor(sparkCount * 0.32)), photoEmit);
                } else {
                    for (let i = 0; i < sparkCount; i++) {
                        const p = getParticle();
                        if (!p) break;
                        photoEmit(p);
                    }
                }
                return;
            }

            const coreWanted = this.type === 'mini' ? 6 : (this.type === 'finale' ? 26 : 32);
            const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
            if (budget <= 0) return;

            const totalWanted = count + coreWanted;
            const ratio = Math.min(1, budget / totalWanted);
            let mainCount = Math.min(count, Math.floor(count * ratio));
            const coreBudgetLeft = Math.max(0, budget - mainCount);
            let coreCount = Math.min(coreWanted, coreBudgetLeft);

            if (this.type === 'finale' && CONFIG.force60Mode) {
                mainCount = Math.min(mainCount, STATE.fps < 45 ? 24 : 32);
                coreCount = Math.min(coreCount, 8);
            }

            const mainEmit = (p) => {
                const a = rand(0, Math.PI * 2);
                const speedPf = this.radius * rand(CONFIG.streakSpeedFactor[0], CONFIG.streakSpeedFactor[1]);
                const speed = speedPf * 60;
                p.reset({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed,
                    gravity: rand(60, 140),
                    drag: rand(0.986, 0.994),
                    life: rand(CONFIG.streakLifeMs[0], CONFIG.streakLifeMs[1]),
                    color: pick(colors),
                    width: rand(CONFIG.streakWidth[0], CONFIG.streakWidth[1]),
                    kind: opt.kind || 'main',
                    sparkle: true,
                    sparkColor: '#fff8e5'
                });
            };
            const coreEmit = (p) => {
                const a = rand(0, Math.PI * 2);
                const v = this.radius * rand(0.004, 0.008) * 60;
                p.reset({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(a) * v,
                    vy: Math.sin(a) * v,
                    gravity: rand(40, 90),
                    drag: rand(0.987, 0.995),
                    life: rand(300, 640),
                    color: '#fff6d8',
                    width: rand(0.9, 1.6),
                    kind: 'trail'
                });
            };

            if (CONFIG.force60Mode) {
                enqueueSpawnTask(mainCount, Math.max(16, Math.floor(mainCount * 0.30)), mainEmit);
                enqueueSpawnTask(coreCount, Math.max(8, Math.floor(coreCount * 0.55)), coreEmit);
            } else {
                for (let i = 0; i < mainCount; i++) {
                    const p = getParticle();
                    if (!p) break;
                    mainEmit(p);
                }
                for (let i = 0; i < coreCount; i++) {
                    const p = getParticle();
                    if (!p) break;
                    coreEmit(p);
                }
            }
        }

        update(dt) {
            this.ageMs += dt;
            this.frameAge += dt / (1000 / 60);
            const ttl = this.type === 'photo'
                ? Math.max(1800, this.ringLifeMs + 380)
                : 1700;
            if (this.ageMs > ttl) this.dead = true;
        }

        blur() {
            if (this.type === 'photo') {
                if (STATE.lowPowerMode || STATE.fps < 50) return 0;
                if (isMobile || isWeChat) {
                    if (this.frameAge <= 5) return 1;
                    return 0;
                }
                if (this.frameAge <= 7) return 2;
                return 0;
            }
            if (isMobile || isWeChat) {
                if (STATE.lowPowerMode || STATE.fps < 50) return 0;
                if (this.frameAge <= 4) return 2;
                if (this.frameAge <= 10) return 1;
                return 0;
            }
            if (STATE.lowPowerMode) return 0;
            if (this.frameAge <= CONFIG.shadowStrongFrames) return this.blurStrong;
            if (this.frameAge <= CONFIG.shadowTotalFrames) return this.blurWeak;
            return 0;
        }

        drawPhotoRing(g, liteMode) {
            if (this.type !== 'photo' || !this.photoRingSprite) return;

            const p = clamp(this.ageMs / Math.max(1, this.ringLifeMs), 0, 1);
            const ease = 1 - Math.pow(1 - p, 2.2);
            const scale = this.ringScaleStart + (this.ringScaleEnd - this.ringScaleStart) * ease;
            const fadeIn = Math.min(1, p / 0.16);
            const fadeOut = p < 0.56 ? 1 : (1 - (p - 0.56) / 0.44);
            const alpha = clamp(fadeIn * fadeOut * this.ringAlpha, 0, 1);
            if (alpha <= 0.01) return;

            const rot = this.ringRotation + this.ringSpin * (this.ageMs * 0.001);
            const size = this.photoRingSprite.size * scale;

            g.save();
            g.translate(this.x, this.y);
            g.rotate(rot);
            g.globalAlpha = alpha;
            g.drawImage(this.photoRingSprite.canvas, -size * 0.5, -size * 0.5, size, size);
            if (!liteMode && !STATE.lowPowerMode) {
                const glowSize = size * 1.08;
                g.globalAlpha = alpha * 0.34;
                g.drawImage(this.photoRingSprite.canvas, -glowSize * 0.5, -glowSize * 0.5, glowSize, glowSize);
            }
            g.restore();
        }

        drawFinaleShell(g, liteMode) {
            if (this.type !== 'finale' || !this.finaleShellSprite) return;

            const p = clamp(this.ageMs / Math.max(1, this.ringLifeMs), 0, 1);
            const ease = 1 - Math.pow(1 - p, 2.1);
            const scale = this.ringScaleStart + (this.ringScaleEnd - this.ringScaleStart) * ease;
            const fadeIn = Math.min(1, p / 0.13);
            const fadeOut = p < 0.60 ? 1 : (1 - (p - 0.60) / 0.40);
            const alpha = clamp(fadeIn * fadeOut * this.ringAlpha, 0, 1);
            if (alpha <= 0.01) return;

            const rot = this.ringRotation + this.ringSpin * (this.ageMs * 0.001);
            const size = this.finaleShellSprite.size * scale;
            g.save();
            g.translate(this.x, this.y);
            g.rotate(rot);
            g.globalAlpha = alpha;
            g.drawImage(this.finaleShellSprite.canvas, -size * 0.5, -size * 0.5, size, size);
            if (!liteMode && !STATE.lowPowerMode) {
                const bloom = size * 1.05;
                g.globalAlpha = alpha * 0.24;
                g.drawImage(this.finaleShellSprite.canvas, -bloom * 0.5, -bloom * 0.5, bloom, bloom);
            }
            g.restore();
        }

        drawCenterFlash(g, liteMode) {
            if (this.frameAge > CONFIG.shadowTotalFrames + (this.type === 'photo' ? 4 : 0)) return;
            const sprite = getFlashSprite(this.type, this.radius, liteMode);
            if (!sprite) return;

            let alpha = 1 - clamp(this.frameAge / (CONFIG.shadowTotalFrames + (this.type === 'photo' ? 4 : 0)), 0, 1);
            if (this.type === 'photo') {
                const warm = clamp(this.ageMs / 160, 0, 1);
                alpha *= warm;
            }
            if (alpha <= 0.01) return;

            const scale = this.type === 'photo' ? (1 + clamp(this.ageMs / 420, 0, 0.42)) : 1;
            const size = sprite.size * scale;
            g.globalAlpha = alpha * (liteMode ? 0.74 : 1);
            g.drawImage(sprite.canvas, this.x - size * 0.5, this.y - size * 0.5, size, size);
        }
    }

    function chooseBurstRadius(type) {
        if (type === 'finale') {
            return STATE.minDim * rand(CONFIG.finaleBurstRadius[0], CONFIG.finaleBurstRadius[1]);
        }
        if (type === 'mini') {
            return STATE.minDim * rand(0.08, 0.16);
        }
        if (STATE.lowPowerMode) {
            return STATE.minDim * rand(CONFIG.photoBurstRadiusLow[0], CONFIG.photoBurstRadiusLow[1]);
        }
        return STATE.minDim * rand(CONFIG.photoBurstRadiusHigh[0], CONFIG.photoBurstRadiusHigh[1]);
    }

    function countForBurst(type) {
        if (type === 'finale') {
            if (CONFIG.force60Mode) {
                return randInt(CONFIG.finaleBurstCountForce60[0], CONFIG.finaleBurstCountForce60[1]);
            }
            const range = calcScaledRange(CONFIG.finaleStreakCountHigh, CONFIG.finaleStreakCountLow);
            return randInt(range[0], range[1]);
        }
        if (type === 'mini') {
            const range = calcScaledRange(CONFIG.miniBurstCountHigh, CONFIG.miniBurstCountLow);
            return randInt(range[0], range[1]);
        }
        const range = calcScaledRange(CONFIG.photoStreakCountHigh, CONFIG.photoStreakCountLow);
        const n = randInt(range[0], range[1]);
        return STATE.lowPowerMode ? Math.max(Math.round(CONFIG.photoStreakCountLow[0] * 0.94), n) : n;
    }

    function paletteFor(type) {
        if (type === 'finale') return CONFIG.finaleColorPalette;
        if (type === 'mini') return ['#ffd9a6', '#ffc67d', '#ffb36a', '#fff1d4'];
        return ['#4ea7ff', '#6b8dff', '#8f6cff', '#52e1ff', '#d080ff'];
    }

    function onRocketExplode(rocket) {
        if (rocket.type === 'mini') {
            bursts.push(new Burst({
                type: 'mini',
                x: rocket.x,
                y: rocket.y,
                radius: chooseBurstRadius('mini'),
                count: countForBurst('mini'),
                palette: paletteFor('mini'),
                kind: 'mini'
            }));
            return;
        }

        if (rocket.type === 'finale') {
            bursts.push(new Burst({
                type: 'finale',
                x: rocket.x,
                y: rocket.y,
                radius: chooseBurstRadius('finale'),
                count: countForBurst('finale'),
                palette: paletteFor('finale'),
                kind: 'main'
            }));
            return;
        }
    }

    function spawnMainPhotoRocket(index) {
        const tx = STATE.width * rand(CONFIG.photoTargetX[0], CONFIG.photoTargetX[1]);
        const ty = STATE.height * rand(CONFIG.photoTargetY[0], CONFIG.photoTargetY[1]);
        photoFireworks.push(new PhotoFirework({
            imageIndex: index,
            isLast: index === CONFIG.imageCount,
            startX: STATE.width * rand(0.40, 0.60),
            tx,
            ty
        }));
    }

    function spawnMiniRocket() {
        const tx = STATE.width * rand(CONFIG.miniTargetX[0], CONFIG.miniTargetX[1]);
        const ty = STATE.height * rand(CONFIG.miniTargetY[0], CONFIG.miniTargetY[1]);
        rockets.push(new Rocket({
            type: 'mini',
            startX: STATE.width * rand(0.08, 0.92),
            tx,
            ty
        }));
    }

    function spawnFinaleVolley() {
        let volleyMin = CONFIG.finaleVolleyCountRange[0];
        let volleyMax = CONFIG.finaleVolleyCountRange[1];

        if (CONFIG.force60Mode) {
            volleyMin = CONFIG.finaleVolleyCountRangeForce60[0];
            volleyMax = CONFIG.finaleVolleyCountRangeForce60[1];
        }

        if (!CONFIG.force60Mode && (STATE.fps < 52 || STATE.lowPowerMode)) {
            volleyMin = Math.max(2, volleyMin - 1);
            volleyMax = Math.max(volleyMin, volleyMax - 2);
        }
        if (!CONFIG.force60Mode && STATE.fps < 45) {
            volleyMin = Math.max(1, volleyMin - 1);
            volleyMax = Math.max(volleyMin, volleyMax - 1);
        }
        if (!CONFIG.force60Mode && STATE.fps < 38) {
            volleyMin = 1;
            volleyMax = Math.max(1, volleyMax - 2);
        }

        if (CONFIG.force60Mode) {
            const lim = currentParticleLimit();
            if (activeParticles.length > lim * 0.74 || spawnTasks.length > 18) {
                return;
            }
        }

        const n = randInt(volleyMin, volleyMax);
        for (let i = 0; i < n; i++) {
            const tx = STATE.width * rand(CONFIG.finaleTargetX[0], CONFIG.finaleTargetX[1]);
            const ty = STATE.height * rand(CONFIG.finaleTargetY[0], CONFIG.finaleTargetY[1]);
            rockets.push(new Rocket({
                type: 'finale',
                startX: STATE.width * rand(0.08, 0.92),
                tx,
                ty
            }));
        }
    }

    function startFinale() {
        STATE.phase = CONFIG.phase.finale;
        STATE.finaleStartedAt = nowMs();
        STATE.finaleEndsAt = STATE.finaleStartedAt + CONFIG.finaleHoldMs;
        STATE.nextFinaleVolleyAt = STATE.finaleStartedAt;
        STATE.finalePendingAt = 0;
        STATE.finaleFading = false;
        STATE.finaleFadeStart = 0;
        STATE.finaleGreetingShown = false;
        STATE.finaleGreetingStart = 0;
        rockets.length = 0;
        bursts.length = 0;
        activeParticles.length = 0;
        photoFireworks.length = 0;
        spawnTasks.length = 0;
    }

    function updatePhotoShow(now) {
        if (STATE.mainImageIndex <= CONFIG.imageCount && now >= STATE.nextPhotoLaunchAt) {
            spawnMainPhotoRocket(STATE.mainImageIndex);
            STATE.mainImageIndex += 1;
            STATE.nextPhotoLaunchAt = now + rand(CONFIG.photoGapMs[0], CONFIG.photoGapMs[1]);
        }

        if (now >= STATE.nextMiniLaunchAt) {
            // Ê∂ì‚Ç¨Â®Ü‚ÑÉÊ∏∂Êæ∂?1 Ê∂ìÓÅÑÁö¨ÈêëÁÜªÂß≥
            spawnMiniRocket();
            scheduleNextMini(now);
        }

        if (STATE.finalePendingAt > 0 && now >= STATE.finalePendingAt) {
            startFinale();
        }
    }

    function updateFinale(now) {
        if (STATE.finaleGreetingShown) return;

        if (now >= STATE.nextFinaleVolleyAt) {
            const particleLimit = currentParticleLimit();
            const particleLoad = activeParticles.length / Math.max(1, particleLimit);
            const queueLoad = spawnTasks.length;
            if (particleLoad < 0.72 && queueLoad < 10) {
                spawnFinaleVolley();
            }
            let interval = CONFIG.force60Mode
                ? rand(CONFIG.finaleVolleyIntervalForce60[0], CONFIG.finaleVolleyIntervalForce60[1])
                : rand(CONFIG.finaleVolleyInterval[0], CONFIG.finaleVolleyInterval[1]);
            if (STATE.lowPowerMode) interval += 280;
            else if (STATE.fps < 45) interval += 300;
            if (particleLoad > 0.64) interval += 320;
            if (queueLoad > 8) interval += 320;
            STATE.nextFinaleVolleyAt = now + interval;
        }

        if (now >= STATE.finaleEndsAt) {
            STATE.finaleGreetingShown = true;
            STATE.finaleGreetingStart = now;
            STATE.nextFinaleVolleyAt = Infinity;
            rockets.length = 0;
            bursts.length = 0;
            activeParticles.length = 0;
            spawnTasks.length = 0;
        }
    }

    function scheduleNextMini(now) {
        const range = calcScaledRange(CONFIG.miniGapHigh, CONFIG.miniGapLow);
        STATE.nextMiniLaunchAt = now + rand(range[0], range[1]);
    }

    function fitLoadingTitles() {
        if (!festiveTextBox) return;
        const vh = Math.max(1, STATE.height);
        const vw = Math.max(1, STATE.width);

        const targetHeight = vh * 0.8;
        const maxTextWidth = vw * 0.93;
        const charWidthFactor = 4.18;
        const subRatio = 0.92;

        const gap = Math.max(10, Math.min(38, targetHeight * 0.03));
        const byHeight = (targetHeight - gap) / ((1.08) + (subRatio * 1.08));
        const byWidthMain = maxTextWidth / charWidthFactor;
        const byWidthSub = (maxTextWidth / charWidthFactor) / subRatio;

        let main = Math.min(byHeight, byWidthMain, byWidthSub);
        main = Math.max(48, Math.min(main, Math.min(vh * 0.38, 220)));
        const sub = main * subRatio;

        document.documentElement.style.setProperty('--title-main-size', `${Math.round(main)}px`);
        document.documentElement.style.setProperty('--title-sub-size', `${Math.round(sub)}px`);
        document.documentElement.style.setProperty('--title-gap-size', `${Math.round(gap)}px`);
    }

    function updateViewportVar() {
        const vvh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
        document.documentElement.style.setProperty('--vvh', `${Math.max(1, Math.floor(vvh))}px`);
    }

    function applyViewportSize(force = false) {
        const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
        const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

        const newWidth = Math.max(1, Math.floor(vw));
        const newHeight = Math.max(1, Math.floor(vh));

        updateViewportVar();

        const deviceDpr = window.devicePixelRatio || 1;
        const normalCap = (isMobile || isWeChat) ? CONFIG.dprHighCap : CONFIG.dprDesktopCap;
        const cap = STATE.lowPowerMode ? CONFIG.dprLowCap : normalCap;
        const nextDpr = Math.min(deviceDpr, cap);

        if (!force && STATE.width > 0 && STATE.height > 0) {
            const dw = Math.abs(newWidth - STATE.width);
            const dh = Math.abs(newHeight - STATE.height);
            const wr = dw / Math.max(1, STATE.width);
            const hr = dh / Math.max(1, STATE.height);
            const dprDelta = Math.abs(nextDpr - STATE.dpr);
            const pxThreshold = Math.max(3, Math.round(Math.min(newWidth, newHeight) * 0.012));
            if (dw < pxThreshold && dh < pxThreshold && wr < 0.015 && hr < 0.015 && dprDelta < 0.02) return;
        }

        const prevMinDim = STATE.minDim;
        const prevDpr = STATE.dpr;
        const prevArea = Math.max(1, STATE.width * STATE.height);

        STATE.width = newWidth;
        STATE.height = newHeight;
        STATE.minDim = Math.min(STATE.width, STATE.height);
        STATE.dpr = nextDpr;

        const targetCanvasWidth = Math.max(1, Math.floor(STATE.width * STATE.dpr));
        const targetCanvasHeight = Math.max(1, Math.floor(STATE.height * STATE.dpr));
        const canvasChanged = force || canvas.width !== targetCanvasWidth || canvas.height !== targetCanvasHeight;
        if (canvasChanged) {
            canvas.width = targetCanvasWidth;
            canvas.height = targetCanvasHeight;

            // Èñ¨ÂûÆÂé§ÁºÇ‚ïÇÊñÅÁª±Óàú–ù bug
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.setTransform(STATE.dpr, 0, 0, STATE.dpr, 0, 0);
        }

        fitLoadingTitles();

        const dprChanged = Math.abs(STATE.dpr - prevDpr) > 0.02;
        const minDimChanged = prevMinDim > 0
            ? Math.abs(STATE.minDim - prevMinDim) / prevMinDim > 0.06
            : true;
        const areaChanged = Math.abs((STATE.width * STATE.height) - prevArea) / prevArea > 0.08;
        if (dprChanged || minDimChanged || areaChanged || force) {
            rebuildBackgroundDecor();
        }
        if (dprChanged || minDimChanged || areaChanged) {
            clearRenderCaches();
            if (STATE.running && STATE.phase !== CONFIG.phase.finale) rebuildPhotoCache();
        }
    }

    function loadImagesThenStart() {
        if (STATE.loadRequested) return;
        STATE.loadRequested = true;
        let loaded = 0;

        function done() {
            loaded += 1;
            if (loaded < CONFIG.imageCount) return;
            STATE.assetsLoaded = true;
            setTitleLoadingBlink(false);
            rebuildPhotoCache();
            scheduleStartShow();
        }

        for (let i = 1; i <= CONFIG.imageCount; i++) {
            const img = new Image();
            img.onload = done;
            img.onerror = done;
            img.src = `${CONFIG.imagePrefix}${i}.jpg`;
            images[i] = img;
        }
    }

    function buildPhotoCacheItem(index) {
        const img = images[index];
        if (!img || !img.complete || img.naturalWidth === 0) {
            photoCache[index] = null;
            return;
        }

        const baseR = STATE.minDim * (STATE.lowPowerMode ? 0.28 : 0.32);
        const size = baseR * 2 + 4;

        const off = document.createElement('canvas');
        off.width = Math.ceil(size * STATE.dpr);
        off.height = Math.ceil(size * STATE.dpr);
        const g = off.getContext('2d');
        if (!g) {
            photoCache[index] = null;
            return;
        }

        g.setTransform(1, 0, 0, 1, 0, 0);
        g.setTransform(STATE.dpr, 0, 0, STATE.dpr, 0, 0);

        const cx = size * 0.5;
        const cy = size * 0.5;

        g.save();
        g.beginPath();
        g.arc(cx, cy, baseR, 0, Math.PI * 2);
        g.clip();

        const ir = img.naturalWidth / img.naturalHeight;
        let dw;
        let dh;
        if (ir >= 1) {
            dh = baseR * 2;
            dw = dh * ir;
        } else {
            dw = baseR * 2;
            dh = dw / ir;
        }
        g.drawImage(img, cx - dw * 0.5, cy - dh * 0.5, dw, dh);

        const featherInner = baseR * (1 - CONFIG.featherRatio);
        const mask = g.createRadialGradient(cx, cy, featherInner, cx, cy, baseR);
        mask.addColorStop(0, 'rgba(255,255,255,1)');
        mask.addColorStop(1, 'rgba(255,255,255,0)');
        g.globalCompositeOperation = 'destination-in';
        g.fillStyle = mask;
        g.beginPath();
        g.arc(cx, cy, baseR, 0, Math.PI * 2);
        g.fill();
        g.restore();

        photoCache[index] = off;
    }

    function rebuildPhotoCache() {
        if (STATE.phase === CONFIG.phase.finale) return;

        photoCacheBuildToken += 1;
        const token = photoCacheBuildToken;
        if (photoCacheBuildRaf) {
            cancelAnimationFrame(photoCacheBuildRaf);
            photoCacheBuildRaf = 0;
        }

        const indices = [];
        for (let i = 1; i <= CONFIG.imageCount; i++) indices.push(i);

        const batchSize = (isMobile || isWeChat) ? 1 : 2;
        const step = () => {
            if (token !== photoCacheBuildToken) return;
            if (STATE.phase === CONFIG.phase.finale) {
                photoCacheBuildRaf = 0;
                return;
            }

            for (let i = 0; i < batchSize && indices.length > 0; i++) {
                const idx = indices.shift();
                buildPhotoCacheItem(idx);
            }

            if (indices.length > 0) {
                photoCacheBuildRaf = requestAnimationFrame(step);
            } else {
                photoCacheBuildRaf = 0;
            }
        };

        photoCacheBuildRaf = requestAnimationFrame(step);
    }

    function pushDt(dt) {
        if (dtCount < CONFIG.dtWindowSize) {
            dtRing[dtIndex] = dt;
            dtSum += dt;
            dtCount += 1;
            dtIndex = (dtIndex + 1) % CONFIG.dtWindowSize;
        } else {
            dtSum -= dtRing[dtIndex];
            dtRing[dtIndex] = dt;
            dtSum += dt;
            dtIndex = (dtIndex + 1) % CONFIG.dtWindowSize;
        }

        STATE.avgDt = dtSum / Math.max(1, dtCount);
        STATE.fps = Math.round(1000 / STATE.avgDt);
    }

    function updateQuality() {
        if (CONFIG.force60Mode && STATE.phase === CONFIG.phase.finale) {
            let target = 0.66;
            if (STATE.fps < 50) target = 0.58;
            if (STATE.fps < 44) target = 0.50;
            if (STATE.fps < 38) target = 0.44;
            STATE.targetQualityScale = target;
            STATE.qualityScale += (STATE.targetQualityScale - STATE.qualityScale) * 0.12;
            STATE.qualityScale = Math.max(0.42, Math.min(0.72, STATE.qualityScale));
            if (!STATE.lowPowerMode) {
                STATE.lowPowerMode = true;
                clearRenderCaches();
                applyViewportSize(true);
            }
            return;
        }

        let target = 1;
        if (CONFIG.force60Mode) {
            if (STATE.avgDt > 22 || STATE.fps < 42) target = 0.55;
            else if (STATE.avgDt > 18 || STATE.fps < 50) target = 0.68;
            else if (STATE.avgDt > 16.8 || STATE.fps < 58) target = 0.82;
            else target = 0.94;
        } else {
            if (STATE.avgDt > 24 || STATE.fps < 38) target = 0.58;
            else if (STATE.avgDt > 20 || STATE.fps < 44) target = 0.72;
            else if (STATE.avgDt > 17 || STATE.fps < 52) target = 0.86;
        }

        STATE.targetQualityScale = target;
        STATE.qualityScale += (STATE.targetQualityScale - STATE.qualityScale) * 0.08;
        STATE.qualityScale = Math.max(0.55, Math.min(1, STATE.qualityScale));

        const shouldLow = STATE.qualityScale < 0.8;
        if (shouldLow && !STATE.lowPowerMode) {
            STATE.lowPowerMode = true;
            STATE.recoverCounter = 0;
            clearRenderCaches();
            applyViewportSize(true);
            return;
        }

        if (!shouldLow && STATE.lowPowerMode) {
            if (STATE.avgDt < CONFIG.highExitDt && STATE.fps > CONFIG.highExitFps) {
                STATE.recoverCounter += 1;
                if (STATE.recoverCounter >= CONFIG.highRecoverFrames) {
                    STATE.lowPowerMode = false;
                    STATE.recoverCounter = 0;
                    clearRenderCaches();
                    applyViewportSize(true);
                }
            } else {
                STATE.recoverCounter = 0;
            }
        }
    }

    function updateEntities(dt, now) {
        if (STATE.phase === CONFIG.phase.photoShow) updatePhotoShow(now);
        else updateFinale(now);

        // Consume queued particle tasks in small slices each frame.
        if (!CONFIG.force60Mode || STATE.phase !== CONFIG.phase.finale || (frameTick & 1) === 0) {
            processSpawnTasks();
        }

        for (let i = rockets.length - 1; i >= 0; i--) {
            rockets[i].update(dt);
            if (rockets[i].done) rockets.splice(i, 1);
        }

        for (let i = photoFireworks.length - 1; i >= 0; i--) {
            photoFireworks[i].update(dt);
            if (photoFireworks[i].dead) photoFireworks.splice(i, 1);
        }

        for (let i = bursts.length - 1; i >= 0; i--) {
            bursts[i].update(dt);
            if (bursts[i].dead) bursts.splice(i, 1);
        }

        for (let i = activeParticles.length - 1; i >= 0; i--) {
            activeParticles[i].update(dt);
            if (!activeParticles[i].active) recycleParticle(i);
        }

        if (!(CONFIG.force60Mode && STATE.phase === CONFIG.phase.finale)) {
            processSpawnTasks();
        }
    }

    function drawBackgroundFog(now) {
        if (STATE.phase !== CONFIG.phase.finale) return;
        if (STATE.finaleGreetingShown) return;
        if (CONFIG.force60Mode) return;
        if (STATE.lowPowerMode) return;
        if ((isMobile || isWeChat) && now < STATE.nextFogAt) return;
        if (isMobile || isWeChat) STATE.nextFogAt = now + 85;

        const t = now * 0.001;
        const alpha = (isMobile || isWeChat) ? 0.022 : 0.030;
        const x = STATE.width * (0.5 + Math.sin(t * 0.17) * 0.18);
        const y = STATE.height * 0.45;
        const r = STATE.minDim * 0.72;

        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, `rgba(170,24,24,${alpha})`);
        g.addColorStop(1, 'rgba(170,24,24,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }

    function draw(now) {
        drawState.stroke = '';
        drawState.fill = '';

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        const clearA = STATE.lowPowerMode ? CONFIG.clearAlphaLow : CONFIG.clearAlphaHigh;
        drawPhaseBackground(now, clearA);

        drawBackgroundFog(now);

        for (let i = 0; i < rockets.length; i++) rockets[i].draw(ctx);
        for (let i = 0; i < photoFireworks.length; i++) photoFireworks[i].drawRocket(ctx);

        let maxBlur = 0;
        for (let i = 0; i < bursts.length; i++) {
            const b = bursts[i].blur();
            if (b > maxBlur) maxBlur = b;
        }
        if (photoFireworks.length > 0 && !STATE.lowPowerMode && STATE.fps >= 48) {
            maxBlur = Math.max(maxBlur, (isMobile || isWeChat) ? 1 : 2);
        }
        if (CONFIG.force60Mode && STATE.phase !== CONFIG.phase.finale) maxBlur = 0;

        // lighter Êµ†ÂëØÊï§ÊµúÂ∫£ÂÑ´Èë∫Ëæ©ÁüëÁÄõÊÑ≠ÓÜå
        ctx.save();
        const mobileHeavy = CONFIG.force60Mode
            ? (STATE.phase === CONFIG.phase.finale
                ? true
                : true)
            : ((isMobile || isWeChat) && (STATE.lowPowerMode || STATE.fps < 50));
        ctx.globalCompositeOperation = mobileHeavy ? 'source-over' : 'lighter';
        if (maxBlur > 0) {
            let blur = maxBlur;
            if (isMobile || isWeChat) blur = Math.min(2, blur);
            if (STATE.lowPowerMode || STATE.fps < 50) blur = 0;
            ctx.shadowBlur = blur;
            ctx.shadowColor = STATE.phase === CONFIG.phase.finale
                ? 'rgba(255,220,170,0.9)'
                : 'rgba(180,220,255,0.9)';
        } else {
            ctx.shadowBlur = 0;
        }

        for (let i = 0; i < photoFireworks.length; i++) {
            photoFireworks[i].drawBurst(ctx, mobileHeavy);
        }

        for (let i = 0; i < bursts.length; i++) {
            bursts[i].drawPhotoRing(ctx, mobileHeavy);
        }
        for (let i = 0; i < bursts.length; i++) {
            bursts[i].drawFinaleShell(ctx, mobileHeavy);
        }

        if (
            !CONFIG.force60Mode ||
            STATE.phase !== CONFIG.phase.finale ||
            (frameTick % CONFIG.finaleParticleFrameSkipForce60) === 0
        ) {
            drawParticlesBatched(ctx);
        }

        const flashLite = isMobile || isWeChat;
        const allFlashCount = bursts.length + photoFireworks.length;
        const flashMax = flashLite ? ((STATE.lowPowerMode || STATE.fps < 50) ? 2 : 5) : allFlashCount;
        let flashCount = 0;
        for (let i = 0; i < photoFireworks.length; i++) {
            if (flashCount >= flashMax) break;
            photoFireworks[i].drawCenterFlash(ctx, flashLite);
            flashCount += 1;
        }
        for (let i = 0; i < bursts.length; i++) {
            if (flashCount >= flashMax) break;
            bursts[i].drawCenterFlash(ctx, flashLite);
            flashCount += 1;
        }
        ctx.restore();

        if (STATE.phase === CONFIG.phase.photoShow) {
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            for (let i = 0; i < photoFireworks.length; i++) {
                photoFireworks[i].drawPhoto(ctx);
            }
            ctx.restore();
        }

        if (STATE.phase === CONFIG.phase.finale && CONFIG.finaleEndMode === 'fadeout' && STATE.finaleFading) {
            const p = Math.min(1, (now - STATE.finaleFadeStart) / CONFIG.finaleFadeoutMs);
            ctx.fillStyle = `rgba(0,0,0,${p * 0.9})`;
            ctx.fillRect(0, 0, STATE.width, STATE.height);
        }

        if (STATE.phase === CONFIG.phase.finale && STATE.finaleGreetingShown) {
            drawFinaleGreeting(now);
        }
    }

    function updateDebug() {
        if (!debugOn) return;
        let rocketUpCount = 0;
        let burstExpandCount = 0;
        let fallRevealCount = 0;
        for (let i = 0; i < photoFireworks.length; i++) {
            const s = photoFireworks[i].stage;
            if (s === photoStage.rocketUp) rocketUpCount += 1;
            else if (s === photoStage.burstExpand) burstExpandCount += 1;
            else if (s === photoStage.fallReveal) fallRevealCount += 1;
        }
        debugPanel.textContent =
            `FPS: ${STATE.fps}\n` +
            `particles: ${activeParticles.length}\n` +
            `spawnQ: ${spawnTasks.length} budget:${Number.isFinite(spawnBudget) ? spawnBudget : 'inf'}\n` +
            `photoFW: ${photoFireworks.length} (up:${rocketUpCount}, burst:${burstExpandCount}, fall:${fallRevealCount})\n` +
            `phase: ${STATE.phase}\n` +
            `dpr: ${STATE.dpr.toFixed(2)}\n` +
            `mode: ${STATE.lowPowerMode ? 'LowPower' : 'Normal'}\n` +
            `q: ${STATE.qualityScale.toFixed(2)} force60:${CONFIG.force60Mode ? 'on' : 'off'}`;
    }

    function loop(ts) {
        if (!STATE.running) return;
        rafId = requestAnimationFrame(loop);
        frameTick = (frameTick + 1) & 4095;

        const elapsed = ts - lastTs;
        const dt = elapsed > 120 ? 16.67 : Math.min(40, Math.max(8, elapsed));
        lastTs = ts;

        pushDt(dt);
        spawnBudget = currentSpawnBudget();
        updateQuality();
        updateEntities(dt, ts);

        if (STATE.phase === CONFIG.phase.finale && CONFIG.finaleEndMode === 'fadeout' && STATE.finaleFading) {
            if (ts - STATE.finaleFadeStart > CONFIG.finaleFadeoutMs) {
                STATE.nextFinaleVolleyAt = Infinity;
            }
        }

        draw(ts);
        updateDebug();
    }

    function startShow() {
        if (STATE.running) return;
        if (startDelayTimer) {
            clearTimeout(startDelayTimer);
            startDelayTimer = 0;
        }
        STATE.startScheduled = false;
        STATE.running = true;
        STATE.phase = CONFIG.phase.photoShow;
        STATE.mainImageIndex = 1;
        STATE.finalePendingAt = 0;
        STATE.finaleGreetingShown = false;
        STATE.finaleGreetingStart = 0;
        spawnTasks.length = 0;

        const n = nowMs();
        lastTs = n;
        STATE.nextPhotoLaunchAt = n + 250;
        scheduleNextMini(n);

        startOverlay.classList.add('hide');
        setTimeout(() => {
            startOverlay.style.display = 'none';
        }, 850);

        rafId = requestAnimationFrame(loop);
    }

    function scheduleStartShow() {
        if (STATE.running || STATE.startScheduled) return;
        const waitMs = Math.max(0, CONFIG.introHoldExtraMs | 0);
        if (waitMs <= 0) {
            startShow();
            return;
        }
        STATE.startScheduled = true;
        startDelayTimer = window.setTimeout(() => {
            startDelayTimer = 0;
            STATE.startScheduled = false;
            if (!STATE.running) startShow();
        }, waitMs);
    }

    function bindVisibilityPause() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                STATE.pausedByVisibility = true;
                if (STATE.running && rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = 0;
                }
                if (bgMusic && !bgMusic.paused) {
                    bgMusic.pause();
                }
                return;
            }

            if (STATE.pausedByVisibility && STATE.running) {
                STATE.pausedByVisibility = false;
                lastTs = nowMs();
                if (!rafId) rafId = requestAnimationFrame(loop);
            }
            playBackgroundMusic();
        });
    }

    function bindResize() {
        let settleTimer = 0;
        const scheduleApply = () => {
            if (resizeRaf) return;
            resizeRaf = requestAnimationFrame(() => {
                resizeRaf = 0;
                applyViewportSize();
            });
        };
        const onResize = () => {
            scheduleApply();
            if (settleTimer) clearTimeout(settleTimer);
            settleTimer = window.setTimeout(scheduleApply, 140);
        };
        window.addEventListener('resize', onResize, { passive: true });
        window.addEventListener('orientationchange', onResize, { passive: true });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', onResize, { passive: true });
        }
    }

    function ensureStarted() {
        if (!STATE.loadRequested) {
            setTitleLoadingBlink(true);
            loadImagesThenStart();
            return;
        }
        if (STATE.assetsLoaded && !STATE.running) scheduleStartShow();
    }

    function bindStartFallback() {
        const onceStart = () => {
            playBackgroundMusic();
            ensureStarted();
        };
        document.addEventListener('touchstart', onceStart, { passive: true, once: true });
        document.addEventListener('click', onceStart, { passive: true, once: true });
    }

    function bindDebugToggle() {
        if (!debugEnabled) {
            debugToggle.style.display = 'none';
            debugPanel.style.display = 'none';
            return;
        }

        debugToggle.style.display = 'block';
        const toggle = () => {
            debugOn = !debugOn;
            debugToggle.textContent = debugOn ? 'Debug: On' : 'Debug: Off';
            debugPanel.style.display = debugOn ? 'block' : 'none';
        };
        debugToggle.addEventListener('touchstart', toggle, { passive: true });
        debugToggle.addEventListener('click', toggle, { passive: true });
    }

    function init() {
        applyViewportSize(true);
        bindResize();
        bindDebugToggle();
        bindVisibilityPause();
        bindStartFallback();
        if (isWeChat) {
            document.addEventListener('WeixinJSBridgeReady', playBackgroundMusic, false);
        }
        playBackgroundMusic();

        setTitleLoadingBlink(true);
        ensureStarted();
    }

    init();
})();
</script>
</body>
</html>
