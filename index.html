<!DOCTYPE html>
<!--
ÊÄßËÉΩ‰ºòÂåñËØ¥ÊòéÔºàÁßªÂä®Á´Ø/ÂæÆ‰ø°ÈáçÁÇπÔºâÔºö
1) ÁßªÈô§ visualViewport.scroll Ëß¶ÂèëÔºåÈÅøÂÖçÂú∞ÂùÄÊ†èÊªöÂä®ÂØºËá¥È´òÈ¢ë resize ÊäñÂä®„ÄÇ
2) resize Êîπ‰∏∫ requestAnimationFrame ËäÇÊµÅÔºåÂêå‰∏ÄÂ∏ßÂè™ÊâßË°å‰∏ÄÊ¨° applyViewportSize„ÄÇ
3) applyViewportSize Â¢ûÂä† early-returnÔºàÂ∞∫ÂØ∏ÂèòÂåñ <2px Áõ¥Êé•ËøîÂõûÔºâÔºåÈÅøÂÖçÈáçÂ§çÈáçËÆæÁîªÂ∏É„ÄÇ
4) ËøêË°å‰∏≠ÁºìÂ≠òÈáçÂª∫Â¢ûÂä†Êù°‰ª∂Èó®ÊéßÔºö‰ªÖ DPR ÂèòÂåñÊàñ minDim ÂèòÂåñË∂ÖËøá 9% Êó∂Ëß¶Âèë„ÄÇ
5) ÁÖßÁâáÁºìÂ≠òÊîπ‰∏∫ÂàÜÂ∏ßÂ¢ûÈáèÈáçÂª∫ÔºàÊØèÂ∏ß 1~2 Âº†ÔºâÔºåÈò≤Ê≠¢ÂçïÂ∏ßÈòªÂ°û„ÄÇ
6) finale Èò∂ÊÆµË∑≥ËøáÁÖßÁâáÁºìÂ≠òÈáçÂª∫ÔºåÈÅøÂÖçÊó†ÊïàÂºÄÈîÄ„ÄÇ
7) ÁßªÂä®Á´ØÈôç‰Ωé lighter/shadowBlur/centerFlash/fog ÁöÑÂºÄÈîÄÔºå‰ΩéÂäüËÄóËøõ‰∏ÄÊ≠•ÈôçÁ∫ß„ÄÇ
8) Á≤íÂ≠êÂèëÂ∞ÑÂä†ÂÖ•‰∏•Ê†ºÈ¢ÑÁÆóÈôêÊµÅÔºåÈÅøÂÖçÁû¨Êó∂Â≥∞ÂÄºÂØºËá¥ÊéâÂ∏ßÂ∞ñÂ≥∞„ÄÇ
9) rAF ÊÅ¢Â§çÊó∂Èí≥Âà∂Â§ß dtÔºåÈôç‰ΩéÂêéÂè∞ÂàáÂõûÂâçÂè∞ÂêéÁöÑÈó™ÁÉÅ‰∏éÂç°È°ø„ÄÇ
-->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>Êñ∞Âπ¥ÁÉüËä±</title>
    <style>
        :root {
            --vvh: 100vh;
            --title-main-size: 72px;
            --title-sub-size: 66px;
            --title-gap-size: 12px;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
            background: #060609;
            font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", Arial, sans-serif;
        }

        #app {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            overflow: hidden;
            background:
                radial-gradient(120% 120% at 50% 100%, rgba(170, 20, 20, 0.20) 0%, rgba(18, 12, 22, 0.42) 52%, rgba(7, 7, 10, 0.96) 100%),
                linear-gradient(180deg, #120913 0%, #09070d 100%);
        }

        @supports (height: 100dvh) {
            #app {
                height: 100dvh;
            }
        }

        @supports not (height: 100dvh) {
            #app {
                height: 100svh;
            }
        }

        #canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            display: block;
        }

        @supports (height: 100dvh) {
            #canvas {
                height: 100dvh;
            }
        }

        @supports not (height: 100dvh) {
            #canvas {
                height: 100svh;
            }
        }

        #startOverlay {
            position: absolute;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            z-index: 8;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            transition: opacity 0.8s ease;
            background: transparent;
            opacity: 1;
        }

        #startOverlay.hide {
            opacity: 0;
        }

        .festive-wrap {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--vvh, 100vh);
            max-width: none;
            padding: 20px 16px 22px;
            border-radius: 0;
            background: radial-gradient(circle at 50% 35%, rgba(120, 20, 20, 0.42) 0%, rgba(35, 8, 10, 0.52) 75%, rgba(0, 0, 0, 0.16) 100%);
            border: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        .title {
            margin: 0;
            font-family: "STKaiti", "Kaiti SC", "KaiTi", "STXingkai", "Xingkai SC", "Songti SC", serif;
            font-weight: 900;
            line-height: 1.08;
            letter-spacing: 0.04em;
            font-size: clamp(44px, 9vw, 120px);
            background: linear-gradient(132deg, #fff8da 0%, #ffe79a 18%, #ffd66a 38%, #ffba2f 58%, #ffcf68 76%, #fff2c6 100%);
            background-size: 240% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            text-shadow:
                0 0 8px rgba(255, 240, 185, 0.75),
                0 0 20px rgba(255, 214, 112, 0.55),
                0 0 32px rgba(255, 176, 45, 0.42),
                0 1px 0 rgba(140, 62, 0, 0.35),
                0 -1px 0 rgba(255, 247, 214, 0.52);
            opacity: 1;
            animation: titleFlow 12s linear infinite, titleBreath 4.8s ease-in-out infinite;
        }

        .title + .title {
            margin-top: 4px;
        }

        .loading-blink {
            animation: titleFlow 11s linear infinite, titleBreath 4.2s ease-in-out infinite;
        }

        .festive-text-box {
            width: min(96vw, 1300px);
            height: 80vh;
            height: calc(var(--vvh, 100vh) * 0.8);
            display: grid;
            grid-template-rows: auto auto;
            place-items: center;
            align-content: center;
            justify-items: center;
            gap: var(--title-gap-size);
            pointer-events: none;
            box-sizing: border-box;
        }

        .festive-text-box .title,
        .title.main,
        .title.subline {
            position: static !important;
            top: auto !important;
            left: auto !important;
            transform: none !important;
            margin: 0;
        }

        .title.main {
            font-size: var(--title-main-size);
            line-height: 1.08;
        }

        .title.subline {
            font-size: var(--title-sub-size);
            line-height: 1.08;
        }

        .fu-decoration {
            position: fixed;
            width: 1.5em;
            height: 1.5em;
            font-family: "STKaiti", "KaiTi", serif;
            font-size: clamp(34px, 6.8vw, 56px);
            color: #ffd700;
            background: #aa0000;
            border: 2px solid #ffd700;
            transform: rotate(45deg);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 0 10px rgba(255, 228, 136, 0.55),
                0 0 20px rgba(255, 190, 36, 0.45),
                inset 0 0 8px rgba(255, 234, 170, 0.35);
            filter: drop-shadow(0 0 8px rgba(255, 210, 90, 0.62));
        }

        .fu-decoration span {
            transform: rotate(-45deg);
            font-weight: 700;
            margin-top: 0.05em;
        }

        .fu-left {
            left: calc(env(safe-area-inset-left, 0px) + 18px);
            top: calc(env(safe-area-inset-top, 0px) + 18px);
        }

        .fu-right {
            right: calc(env(safe-area-inset-right, 0px) + 18px);
            top: calc(env(safe-area-inset-top, 0px) + 18px);
        }

        .horse-decoration {
            position: fixed;
            font-size: clamp(30px, 6vw, 48px);
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.55));
            opacity: 0.95;
        }

        .horse-left {
            left: calc(env(safe-area-inset-left, 0px) + 18px);
            bottom: calc(env(safe-area-inset-bottom, 0px) + 18px);
            transform: scaleX(-1);
        }

        .horse-right {
            right: calc(env(safe-area-inset-right, 0px) + 18px);
            bottom: calc(env(safe-area-inset-bottom, 0px) + 18px);
        }

        #debugToggle {
            display: none;
            position: absolute;
            right: 8px;
            top: 8px;
            z-index: 20;
            color: rgba(255, 255, 255, 0.84);
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.15);
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            user-select: none;
        }

        #debugPanel {
            position: absolute;
            right: 8px;
            top: 34px;
            z-index: 20;
            display: none;
            color: #d8eaff;
            font-size: 11px;
            line-height: 1.45;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.14);
            white-space: pre;
            pointer-events: none;
        }

        @keyframes titleFlow {
            to {
                background-position: 240% center;
            }
        }

        @keyframes titleBreath {
            0%, 100% {
                filter: brightness(1) saturate(1);
                opacity: 0.96;
            }
            50% {
                filter: brightness(1.08) saturate(1.06);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
<div id="app">
    <canvas id="canvas"></canvas>

    <div id="startOverlay">
        <div class="festive-wrap">
            <div class="fu-decoration fu-left"><span>Á¶è</span></div>
            <div class="fu-decoration fu-right"><span>Á¶è</span></div>
            <div class="horse-decoration horse-left">üêé</div>
            <div class="horse-decoration horse-right">üêé</div>

            <div class="festive-text-box">
                <p class="title main loading-title loading-blink">Êñ∞Âπ¥Â§ßÂêâ</p>
                <p class="title subline loading-title loading-blink">È©¨Âπ¥Â§ßÂêâ</p>
            </div>
        </div>
    </div>

    <div id="debugToggle">Debug: Off</div>
    <div id="debugPanel"></div>
</div>

<script>
/*
 * WeChat compatibility notes
 * 1) Canvas ‰ªÖ‰ΩøÁî® 2DÔºõÂÖàÂ∞ùËØï {alpha:false, desynchronized:true}ÔºåÂ§±Ë¥•ÂõûÈÄÄÊôÆÈÄö 2D„ÄÇ
 * 2) ÂõæÁâáË∑ØÂæÑ‰ΩøÁî® ./picture/x.jpgÔºåÁõ∏ÂØπË∑ØÂæÑÂèØÁõ¥Êé•Áî®‰∫éÂêåÂüü H5„ÄÇ
 * 3) Ëá™Âä®Âä†ËΩΩÂÆåÊàêÂêéÁõ¥Êé•ÂºÄÂßãÔºõclick/touch ‰ªç‰Ωú‰∏∫ÂÖúÂ∫ïËß¶ÂèëÔºå‰∏çÊòæÁ§∫‰ªª‰ΩïÁÇπÂáªÊèêÁ§∫ÊñáÊ°à„ÄÇ
 * 4) resize ÊØèÊ¨°ÂÖà setTransform(1,0,0,1,0,0) ÂÜç setTransform(dpr,0,0,dpr,0,0)ÔºåÈÅøÂÖçÁº©ÊîæÁ¥ØÁßØ„ÄÇ
 * 5) visibilitychange ÂàáÂêéÂè∞ÊöÇÂÅúÊ∏≤ÊüìÔºåÂõûÂâçÂè∞ÊÅ¢Â§çÔºåÂáèÂ∞ëÂæÆ‰ø°ÂêéÂè∞ËÄóÁîµÂíåÂç°È°ø„ÄÇ
 */

(() => {
    const CONFIG = {
        imageCount: 15,
        imagePrefix: './picture/',

        phase: {
            photoShow: 'photoShow',
            finale: 'finale'
        },

        photoGapMs: [2200, 3200],
        photoTargetX: [0.20, 0.80],
        photoTargetY: [0.12, 0.40],
        photoBurstRadiusHigh: [0.38, 0.48],
        photoBurstRadiusLow: [0.30, 0.40],
        photoStreakCountHigh: [240, 340],
        photoStreakCountLow: [150, 230],

        streakSpeedFactor: [0.010, 0.018],
        streakWidth: [0.9, 2.2],
        streakLifeMs: [860, 1480],
        rocketTrailPerFrame: 2,

        shadowBlurStrong: [12, 20],
        shadowBlurWeak: [4, 8],
        shadowStrongFrames: 6,
        shadowTotalFrames: 12,
        centerFlashRadiusRatio: 0.24,

        photoDelayMs: [120, 200],
        photoFadeInMs: 250,
        photoHoldMs: 1450,
        photoFadeOutMs: 680,
        photoDiameterRatio: [0.38, 0.50],
        haloDiameterRatio: [0.55, 0.70],
        featherRatio: 0.18,

        miniGapHigh: [1200, 1800],
        miniGapLow: [1500, 2400],
        miniTargetX: [0.10, 0.90],
        miniTargetY: [0.12, 0.55],
        miniBurstCountHigh: [8, 14],
        miniBurstCountLow: [5, 10],

        finaleDuration: [12000, 18000],
        finaleVolleyInterval: [500, 900],
        finaleVolleyCountRange: [3, 7],
        finaleBurstRadius: [0.45, 0.75],
        finaleTargetX: [0.10, 0.90],
        finaleTargetY: [0.08, 0.55],
        finaleStreakCountHigh: [180, 260],
        finaleStreakCountLow: [120, 190],
        finaleColorPalette: ['#ffefb0', '#ffd676', '#ffb45e', '#ff944f', '#ff6c52', '#fff7df'],
        finaleEndMode: 'loop',
        finaleFadeoutMs: 5000,

        maxParticlesPhotoHigh: 760,
        maxParticlesPhotoLow: 500,
        maxParticlesFinaleHigh: 920,
        maxParticlesFinaleLow: 700,

        dtWindowSize: 30,
        lowEnterFps: 50,
        lowEnterDt: 20,
        highExitFps: 58,
        highExitDt: 16,
        highRecoverFrames: 80,

        dprDesktopCap: 1.8,
        dprHighCap: 1.45,
        dprLowCap: 1.15,

        clearAlphaHigh: 0.20,
        clearAlphaLow: 0.22,

        finaleDelayAfterLastBurst: [1500, 2500]
    };

    const ua = navigator.userAgent || '';
    const isWeChat = /MicroMessenger/i.test(ua);
    const isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);

    const STATE = {
        phase: CONFIG.phase.photoShow,
        running: false,
        pausedByVisibility: false,
        lowPowerMode: false,
        assetsLoaded: false,
        loadRequested: false,

        dpr: 1,
        width: 0,
        height: 0,
        minDim: 0,

        fps: 60,
        avgDt: 16.6,
        recoverCounter: 0,
        qualityScale: 1,
        targetQualityScale: 1,
        nextFogAt: 0,

        mainImageIndex: 1,
        nextPhotoLaunchAt: 0,
        nextMiniLaunchAt: 0,

        finaleStartedAt: 0,
        finaleEndsAt: 0,
        nextFinaleVolleyAt: 0,
        finalePendingAt: 0,
        finaleFading: false,
        finaleFadeStart: 0
    };

    const canvas = document.getElementById('canvas');
    const startOverlay = document.getElementById('startOverlay');
    const debugToggle = document.getElementById('debugToggle');
    const debugPanel = document.getElementById('debugPanel');
    const festiveTextBox = document.querySelector('.festive-text-box');
    const loadingTitles = document.querySelectorAll('.loading-title');
    const debugEnabled = new URLSearchParams(window.location.search).get('debug') === '1';

    let ctx = null;
    try {
        ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    } catch (e) {
        ctx = null;
    }
    if (!ctx) {
        try {
            ctx = canvas.getContext('2d', { alpha: false });
        } catch (e) {
            ctx = null;
        }
    }
    if (!ctx) ctx = canvas.getContext('2d');

    const images = new Array(CONFIG.imageCount + 1);
    const photoCache = new Array(CONFIG.imageCount + 1);

    let photoCacheBuildToken = 0;
    let photoCacheBuildRaf = 0;
    let resizeRaf = 0;

    const rockets = [];
    const bursts = [];
    const photoOverlays = [];

    const activeParticles = [];
    const particlePool = [];

    const dtRing = new Float32Array(CONFIG.dtWindowSize);
    let dtSum = 0;
    let dtCount = 0;
    let dtIndex = 0;

    let lastTs = 0;
    let rafId = 0;
    let debugOn = false;

    const drawState = {
        stroke: '',
        fill: ''
    };

    if (isMobile || isWeChat) {
        CONFIG.maxParticlesPhotoHigh = 600;
        CONFIG.maxParticlesPhotoLow = 380;
        CONFIG.maxParticlesFinaleHigh = 720;
        CONFIG.maxParticlesFinaleLow = 520;
        CONFIG.finaleStreakCountHigh = [140, 210];
        CONFIG.finaleStreakCountLow = [90, 150];
        CONFIG.dprHighCap = 1.25;
        CONFIG.dprLowCap = 1.05;
    }

    function rand(min, max) {
        return min + Math.random() * (max - min);
    }

    function randInt(min, max) {
        return Math.floor(rand(min, max + 1));
    }

    function pick(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function nowMs() {
        return performance.now();
    }

    function setTitleLoadingBlink(isLoading) {
        for (let i = 0; i < loadingTitles.length; i++) {
            if (isLoading) loadingTitles[i].classList.add('loading-blink');
            else loadingTitles[i].classList.remove('loading-blink');
        }
    }

    function currentSparkleChance() {
        if (STATE.lowPowerMode || STATE.fps < 50) return 0;
        if (isMobile || isWeChat) return 0.18;
        return 0.32;
    }

    function currentParticleLimit() {
        const q = STATE.qualityScale;
        if (STATE.phase === CONFIG.phase.finale) {
            return Math.round(CONFIG.maxParticlesFinaleLow + (CONFIG.maxParticlesFinaleHigh - CONFIG.maxParticlesFinaleLow) * q);
        }
        return Math.round(CONFIG.maxParticlesPhotoLow + (CONFIG.maxParticlesPhotoHigh - CONFIG.maxParticlesPhotoLow) * q);
    }

    function calcScaledRange(highRange, lowRange) {
        const q = STATE.qualityScale;
        const min = Math.round(lowRange[0] + (highRange[0] - lowRange[0]) * q);
        const max = Math.round(lowRange[1] + (highRange[1] - lowRange[1]) * q);
        return [Math.min(min, max), Math.max(min, max)];
    }

    class Particle {
        constructor() {
            this.active = false;
        }

        reset(opt) {
            this.x = opt.x;
            this.y = opt.y;
            this.px = opt.x;
            this.py = opt.y;
            this.vx = opt.vx;
            this.vy = opt.vy;
            this.gravity = opt.gravity || 0;
            this.drag = opt.drag || 1;
            this.life = opt.life;
            this.maxLife = opt.life;
            this.color = opt.color;
            this.width = opt.width || 1;
            this.kind = opt.kind || 'main';
            this.sparkle = !!opt.sparkle;
            this.sparkColor = opt.sparkColor || '#fff';
            this.active = true;
        }

        update(dt) {
            const dts = dt / 1000;
            this.px = this.x;
            this.py = this.y;
            this.x += this.vx * dts;
            this.y += this.vy * dts;

            this.vy += this.gravity * dts;
            const dragPow = Math.pow(this.drag, dts * 60);
            this.vx *= dragPow;
            this.vy *= dragPow;

            this.life -= dt;
            if (this.life <= 0) this.active = false;
        }

        draw(g) {
            const a = Math.max(0, this.life / this.maxLife);
            if (a <= 0) return;

            if (this.kind === 'trail' || this.kind === 'dust') {
                g.globalAlpha = a;
                if (drawState.fill !== this.color) {
                    g.fillStyle = this.color;
                    drawState.fill = this.color;
                }
                const s = this.width;
                g.fillRect(this.x - s * 0.5, this.y - s * 0.5, s, s);
                return;
            }

            g.globalAlpha = a;
            if (drawState.stroke !== this.color) {
                g.strokeStyle = this.color;
                drawState.stroke = this.color;
            }
            g.lineWidth = this.width;
            g.beginPath();
            g.moveTo(this.px, this.py);
            g.lineTo(this.x, this.y);
            g.stroke();

            if (this.sparkle && a < 0.55 && Math.random() < currentSparkleChance()) {
                if (drawState.fill !== this.sparkColor) {
                    g.fillStyle = this.sparkColor;
                    drawState.fill = this.sparkColor;
                }
                const s = this.kind === 'main' ? 2.0 : 1.4;
                g.fillRect(this.x - s * 0.5, this.y - s * 0.5, s, s);
            }
        }
    }

    function getParticle() {
        if (activeParticles.length >= currentParticleLimit()) return null;
        let p = particlePool.pop();
        if (!p) p = new Particle();
        activeParticles.push(p);
        return p;
    }

    function recycleParticle(i) {
        const p = activeParticles[i];
        const last = activeParticles.pop();
        if (i < activeParticles.length) activeParticles[i] = last;
        p.active = false;
        particlePool.push(p);
    }

    class Rocket {
        constructor(opt) {
            this.type = opt.type;
            this.imageIndex = opt.imageIndex || 0;
            this.x = opt.startX;
            this.y = STATE.height + rand(6, 18);
            this.tx = opt.tx;
            this.ty = opt.ty;
            this.done = false;
            this.jitterT = rand(0, 999);

            this.vy = -rand(560, 760);
            const flight = Math.max(0.8, (this.y - this.ty) / Math.abs(this.vy));
            this.vx = (this.tx - this.x) / flight;
            this.gravity = rand(320, 460);
        }

        update(dt) {
            const dts = dt / 1000;
            this.jitterT += dts;
            const side = Math.sin(this.jitterT * 16) * 0.7;

            this.x += (this.vx + side) * dts;
            this.y += this.vy * dts;
            this.vy += this.gravity * dts;

            let trailCount;
            if (this.type === 'mini') {
                if (STATE.lowPowerMode || STATE.fps < 45) trailCount = 0;
                else if (STATE.fps < 55) trailCount = 1;
                else trailCount = 1;
            } else {
                if (STATE.lowPowerMode || STATE.fps < 45) trailCount = 0;
                else if (STATE.fps < 55) trailCount = 1;
                else trailCount = 2;
            }

            const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
            trailCount = Math.min(trailCount, budget);

            for (let i = 0; i < trailCount; i++) {
                const p = getParticle();
                if (!p) break;
                p.reset({
                    x: this.x + rand(-2, 2),
                    y: this.y + rand(-2, 2),
                    vx: rand(-18, 18),
                    vy: rand(24, 104),
                    gravity: rand(120, 220),
                    drag: 0.989,
                    life: rand(160, 300),
                    color: '#ffffff',
                    width: rand(1.0, 1.8),
                    kind: 'trail'
                });
            }

            if (this.vy > -15 || this.y <= this.ty) {
                this.done = true;
                onRocketExplode(this);
            }
        }

        draw(g) {
            g.save();
            g.globalCompositeOperation = 'lighter';
            g.globalAlpha = 0.95;
            g.fillStyle = '#fff';
            g.fillRect(this.x - 1.5, this.y - 1.5, 3, 3);
            g.restore();
        }
    }

    class Burst {
        constructor(opt) {
            this.type = opt.type;
            this.x = opt.x;
            this.y = opt.y;
            this.imageIndex = opt.imageIndex || 0;
            this.ageMs = 0;
            this.frameAge = 0;
            this.dead = false;

            this.radius = opt.radius;
            this.photoDiameter = this.radius * rand(CONFIG.photoDiameterRatio[0], CONFIG.photoDiameterRatio[1]);
            this.haloDiameter = this.radius * rand(CONFIG.haloDiameterRatio[0], CONFIG.haloDiameterRatio[1]);

            this.blurStrong = rand(CONFIG.shadowBlurStrong[0], CONFIG.shadowBlurStrong[1]);
            this.blurWeak = rand(CONFIG.shadowBlurWeak[0], CONFIG.shadowBlurWeak[1]);

            this.spawnParticles(opt);
        }

        spawnParticles(opt) {
            const colors = opt.palette;
            const count = opt.count;

            const coreWanted = this.type === 'mini' ? 6 : (this.type === 'finale' ? 26 : 32);
            const budget = Math.max(0, currentParticleLimit() - activeParticles.length);
            if (budget <= 0) return;

            const totalWanted = count + coreWanted;
            const ratio = Math.min(1, budget / totalWanted);
            const mainCount = Math.min(count, Math.floor(count * ratio));
            const coreBudgetLeft = Math.max(0, budget - mainCount);
            const coreCount = Math.min(coreWanted, coreBudgetLeft);

            for (let i = 0; i < mainCount; i++) {
                const p = getParticle();
                if (!p) break;

                const a = rand(0, Math.PI * 2);
                const speedPf = this.radius * rand(CONFIG.streakSpeedFactor[0], CONFIG.streakSpeedFactor[1]);
                const speed = speedPf * 60;
                p.reset({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(a) * speed,
                    vy: Math.sin(a) * speed,
                    gravity: rand(60, 140),
                    drag: rand(0.986, 0.994),
                    life: rand(CONFIG.streakLifeMs[0], CONFIG.streakLifeMs[1]),
                    color: pick(colors),
                    width: rand(CONFIG.streakWidth[0], CONFIG.streakWidth[1]),
                    kind: opt.kind || 'main',
                    sparkle: true,
                    sparkColor: '#fff8e5'
                });
            }

            for (let i = 0; i < coreCount; i++) {
                const p = getParticle();
                if (!p) break;
                const a = rand(0, Math.PI * 2);
                const v = this.radius * rand(0.004, 0.008) * 60;
                p.reset({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(a) * v,
                    vy: Math.sin(a) * v,
                    gravity: rand(40, 90),
                    drag: rand(0.987, 0.995),
                    life: rand(300, 640),
                    color: '#fff6d8',
                    width: rand(0.9, 1.6),
                    kind: 'trail'
                });
            }
        }

        update(dt) {
            this.ageMs += dt;
            this.frameAge += dt / (1000 / 60);
            if (this.ageMs > 1700) this.dead = true;
        }

        blur() {
            if (isMobile || isWeChat) {
                if (STATE.lowPowerMode || STATE.fps < 50) return 0;
                if (this.frameAge <= 4) return 2;
                if (this.frameAge <= 10) return 1;
                return 0;
            }
            if (STATE.lowPowerMode) return 0;
            if (this.frameAge <= CONFIG.shadowStrongFrames) return this.blurStrong;
            if (this.frameAge <= CONFIG.shadowTotalFrames) return this.blurWeak;
            return 0;
        }

        drawCenterFlash(g, liteMode) {
            if (this.frameAge > CONFIG.shadowTotalFrames) return;
            const fr = this.radius * CONFIG.centerFlashRadiusRatio;
            if (liteMode) {
                g.fillStyle = this.type === 'finale' ? 'rgba(255,224,165,0.20)' : 'rgba(255,240,210,0.26)';
                g.beginPath();
                g.arc(this.x, this.y, fr * 0.42, 0, Math.PI * 2);
                g.fill();
                return;
            }
            if (this.type === 'finale') {
                g.fillStyle = 'rgba(255,232,185,0.28)';
                g.beginPath();
                g.arc(this.x, this.y, fr * 0.55, 0, Math.PI * 2);
                g.fill();
                return;
            }
            const grad = g.createRadialGradient(this.x, this.y, 0, this.x, this.y, fr);
            grad.addColorStop(0, 'rgba(255,255,255,0.95)');
            grad.addColorStop(0.35, 'rgba(255,235,200,0.5)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            g.fillStyle = grad;
            g.beginPath();
            g.arc(this.x, this.y, fr, 0, Math.PI * 2);
            g.fill();
        }
    }

    class PhotoOverlay {
        constructor(opt) {
            this.imageIndex = opt.imageIndex;
            this.x = opt.x;
            this.y = opt.y;
            this.photoDiameter = opt.photoDiameter;
            this.haloDiameter = opt.haloDiameter;
            this.delay = rand(CONFIG.photoDelayMs[0], CONFIG.photoDelayMs[1]);
            this.t = 0;
            this.dead = false;
        }

        update(dt) {
            this.t += dt;
            const ttl = this.delay + CONFIG.photoFadeInMs + CONFIG.photoHoldMs + CONFIG.photoFadeOutMs;
            if (this.t > ttl) this.dead = true;
        }

        draw(g) {
            if (STATE.phase !== CONFIG.phase.photoShow) return;
            const img = photoCache[this.imageIndex];
            if (!img || this.t < this.delay) return;

            const t = this.t - this.delay;
            let alpha = 1;
            let scale = 1;

            if (t < CONFIG.photoFadeInMs) {
                const p = t / CONFIG.photoFadeInMs;
                alpha = p;
                scale = 0.88 + 0.12 * p;
            } else if (t < CONFIG.photoFadeInMs + CONFIG.photoHoldMs) {
                alpha = 1;
            } else {
                const p = Math.min(1, (t - CONFIG.photoFadeInMs - CONFIG.photoHoldMs) / CONFIG.photoFadeOutMs);
                alpha = 1 - p;
                scale = 1 + 0.03 * p;
            }

            const haloR = this.haloDiameter * 0.5;
            const halo = g.createRadialGradient(this.x, this.y, this.photoDiameter * 0.25, this.x, this.y, haloR);
            halo.addColorStop(0, 'rgba(0,0,0,0.95)');
            halo.addColorStop(0.62, 'rgba(0,0,0,0.82)');
            halo.addColorStop(1, 'rgba(0,0,0,0)');
            g.fillStyle = halo;
            g.beginPath();
            g.arc(this.x, this.y, haloR, 0, Math.PI * 2);
            g.fill();

            const size = this.photoDiameter * scale;
            g.globalCompositeOperation = 'source-over';
            g.globalAlpha = alpha;
            g.drawImage(img, this.x - size * 0.5, this.y - size * 0.5, size, size);
        }
    }

    function chooseBurstRadius(type) {
        if (type === 'finale') {
            return STATE.minDim * rand(CONFIG.finaleBurstRadius[0], CONFIG.finaleBurstRadius[1]);
        }
        if (type === 'mini') {
            return STATE.minDim * rand(0.08, 0.16);
        }
        if (STATE.lowPowerMode) {
            return STATE.minDim * rand(CONFIG.photoBurstRadiusLow[0], CONFIG.photoBurstRadiusLow[1]);
        }
        return STATE.minDim * rand(CONFIG.photoBurstRadiusHigh[0], CONFIG.photoBurstRadiusHigh[1]);
    }

    function countForBurst(type) {
        if (type === 'finale') {
            const range = calcScaledRange(CONFIG.finaleStreakCountHigh, CONFIG.finaleStreakCountLow);
            return randInt(range[0], range[1]);
        }
        if (type === 'mini') {
            const range = calcScaledRange(CONFIG.miniBurstCountHigh, CONFIG.miniBurstCountLow);
            return randInt(range[0], range[1]);
        }
        const range = calcScaledRange(CONFIG.photoStreakCountHigh, CONFIG.photoStreakCountLow);
        return randInt(range[0], range[1]);
    }

    function paletteFor(type) {
        if (type === 'finale') return CONFIG.finaleColorPalette;
        if (type === 'mini') return ['#ffd9a6', '#ffc67d', '#ffb36a', '#fff1d4'];
        return ['#4ea7ff', '#6b8dff', '#8f6cff', '#52e1ff', '#d080ff'];
    }

    function onRocketExplode(rocket) {
        if (rocket.type === 'mini') {
            bursts.push(new Burst({
                type: 'mini',
                x: rocket.x,
                y: rocket.y,
                radius: chooseBurstRadius('mini'),
                count: countForBurst('mini'),
                palette: paletteFor('mini'),
                kind: 'mini'
            }));
            return;
        }

        if (rocket.type === 'finale') {
            bursts.push(new Burst({
                type: 'finale',
                x: rocket.x,
                y: rocket.y,
                radius: chooseBurstRadius('finale'),
                count: countForBurst('finale'),
                palette: paletteFor('finale'),
                kind: 'main'
            }));
            return;
        }

        const burst = new Burst({
            type: 'photo',
            x: rocket.x,
            y: rocket.y,
            imageIndex: rocket.imageIndex,
            radius: chooseBurstRadius('photo'),
            count: countForBurst('photo'),
            palette: paletteFor('photo'),
            kind: 'main'
        });
        bursts.push(burst);

        photoOverlays.push(new PhotoOverlay({
            imageIndex: rocket.imageIndex,
            x: rocket.x,
            y: rocket.y,
            photoDiameter: burst.photoDiameter,
            haloDiameter: burst.haloDiameter
        }));

        if (rocket.imageIndex === CONFIG.imageCount && STATE.finalePendingAt === 0) {
            STATE.finalePendingAt = nowMs() + rand(CONFIG.finaleDelayAfterLastBurst[0], CONFIG.finaleDelayAfterLastBurst[1]);
        }
    }

    function spawnMainPhotoRocket(index) {
        const tx = STATE.width * rand(CONFIG.photoTargetX[0], CONFIG.photoTargetX[1]);
        const ty = STATE.height * rand(CONFIG.photoTargetY[0], CONFIG.photoTargetY[1]);
        rockets.push(new Rocket({
            type: 'main',
            imageIndex: index,
            startX: STATE.width * rand(0.40, 0.60),
            tx,
            ty
        }));
    }

    function spawnMiniRocket() {
        const tx = STATE.width * rand(CONFIG.miniTargetX[0], CONFIG.miniTargetX[1]);
        const ty = STATE.height * rand(CONFIG.miniTargetY[0], CONFIG.miniTargetY[1]);
        rockets.push(new Rocket({
            type: 'mini',
            startX: STATE.width * rand(0.08, 0.92),
            tx,
            ty
        }));
    }

    function spawnFinaleVolley() {
        let volleyMin = CONFIG.finaleVolleyCountRange[0];
        let volleyMax = CONFIG.finaleVolleyCountRange[1];

        if (STATE.fps < 45 || STATE.lowPowerMode) {
            volleyMin = Math.max(2, volleyMin - 1);
            volleyMax = Math.max(volleyMin, volleyMax - 2);
        }

        const n = randInt(volleyMin, volleyMax);
        for (let i = 0; i < n; i++) {
            const tx = STATE.width * rand(CONFIG.finaleTargetX[0], CONFIG.finaleTargetX[1]);
            const ty = STATE.height * rand(CONFIG.finaleTargetY[0], CONFIG.finaleTargetY[1]);
            rockets.push(new Rocket({
                type: 'finale',
                startX: STATE.width * rand(0.08, 0.92),
                tx,
                ty
            }));
        }
    }

    function startFinale() {
        STATE.phase = CONFIG.phase.finale;
        STATE.finaleStartedAt = nowMs();
        STATE.finaleEndsAt = STATE.finaleStartedAt + rand(CONFIG.finaleDuration[0], CONFIG.finaleDuration[1]);
        STATE.nextFinaleVolleyAt = STATE.finaleStartedAt;
        STATE.finalePendingAt = 0;
        STATE.finaleFading = false;
        STATE.finaleFadeStart = 0;
        photoOverlays.length = 0;
    }

    function updatePhotoShow(now) {
        if (STATE.mainImageIndex <= CONFIG.imageCount && now >= STATE.nextPhotoLaunchAt) {
            spawnMainPhotoRocket(STATE.mainImageIndex);
            STATE.mainImageIndex += 1;
            STATE.nextPhotoLaunchAt = now + rand(CONFIG.photoGapMs[0], CONFIG.photoGapMs[1]);
        }

        if (now >= STATE.nextMiniLaunchAt) {
            // ‰∏ÄÊ¨°ÊúÄÂ§ö 1 ‰∏™Â∞èÁÉüËä±
            spawnMiniRocket();
            scheduleNextMini(now);
        }

        if (STATE.finalePendingAt > 0 && now >= STATE.finalePendingAt) {
            startFinale();
        }
    }

    function updateFinale(now) {
        if (now >= STATE.nextFinaleVolleyAt) {
            spawnFinaleVolley();
            let interval = rand(CONFIG.finaleVolleyInterval[0], CONFIG.finaleVolleyInterval[1]);
            if (STATE.fps < 45 || STATE.lowPowerMode) interval += 200;
            STATE.nextFinaleVolleyAt = now + interval;
        }

        if (now >= STATE.nextMiniLaunchAt) {
            spawnMiniRocket();
            scheduleNextMini(now);
        }

        if (now >= STATE.finaleEndsAt) {
            if (CONFIG.finaleEndMode === 'loop') {
                STATE.finaleStartedAt = now;
                STATE.finaleEndsAt = now + rand(CONFIG.finaleDuration[0], CONFIG.finaleDuration[1]);
            } else if (CONFIG.finaleEndMode === 'fadeout') {
                if (!STATE.finaleFading) {
                    STATE.finaleFading = true;
                    STATE.finaleFadeStart = now;
                }
            }
        }
    }

    function scheduleNextMini(now) {
        const range = calcScaledRange(CONFIG.miniGapHigh, CONFIG.miniGapLow);
        STATE.nextMiniLaunchAt = now + rand(range[0], range[1]);
    }

    function fitLoadingTitles() {
        if (!festiveTextBox) return;
        const vh = Math.max(1, STATE.height);
        const vw = Math.max(1, STATE.width);

        const targetHeight = vh * 0.8;
        const maxTextWidth = vw * 0.93;
        const charWidthFactor = 4.18;
        const subRatio = 0.92;

        const gap = Math.max(10, Math.min(38, targetHeight * 0.03));
        const byHeight = (targetHeight - gap) / ((1.08) + (subRatio * 1.08));
        const byWidthMain = maxTextWidth / charWidthFactor;
        const byWidthSub = (maxTextWidth / charWidthFactor) / subRatio;

        let main = Math.min(byHeight, byWidthMain, byWidthSub);
        main = Math.max(48, Math.min(main, Math.min(vh * 0.38, 220)));
        const sub = main * subRatio;

        document.documentElement.style.setProperty('--title-main-size', `${Math.round(main)}px`);
        document.documentElement.style.setProperty('--title-sub-size', `${Math.round(sub)}px`);
        document.documentElement.style.setProperty('--title-gap-size', `${Math.round(gap)}px`);
    }

    function updateViewportVar() {
        const vvh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
        document.documentElement.style.setProperty('--vvh', `${Math.max(1, Math.floor(vvh))}px`);
    }

    function applyViewportSize() {
        const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
        const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

        const newWidth = Math.max(1, Math.floor(vw));
        const newHeight = Math.max(1, Math.floor(vh));

        if (STATE.width > 0 && STATE.height > 0) {
            const dw = Math.abs(newWidth - STATE.width);
            const dh = Math.abs(newHeight - STATE.height);
            if (dw < 2 && dh < 2) return;
        }

        updateViewportVar();

        const prevMinDim = STATE.minDim;
        const prevDpr = STATE.dpr;

        STATE.width = newWidth;
        STATE.height = newHeight;
        STATE.minDim = Math.min(STATE.width, STATE.height);

        const deviceDpr = window.devicePixelRatio || 1;
        const normalCap = (isMobile || isWeChat) ? CONFIG.dprHighCap : CONFIG.dprDesktopCap;
        const cap = STATE.lowPowerMode ? CONFIG.dprLowCap : normalCap;
        STATE.dpr = Math.min(deviceDpr, cap);

        canvas.width = Math.floor(STATE.width * STATE.dpr);
        canvas.height = Math.floor(STATE.height * STATE.dpr);

        // ÈÅøÂÖçÁº©ÊîæÁ¥ØÁßØ bug
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.setTransform(STATE.dpr, 0, 0, STATE.dpr, 0, 0);

        fitLoadingTitles();

        if (STATE.running && STATE.phase !== CONFIG.phase.finale) {
            const dprChanged = Math.abs(STATE.dpr - prevDpr) > 0.01;
            const minDimChanged = prevMinDim > 0
                ? Math.abs(STATE.minDim - prevMinDim) / prevMinDim > 0.09
                : true;
            if (dprChanged || minDimChanged) rebuildPhotoCache();
        }
    }

    function loadImagesThenStart() {
        if (STATE.loadRequested) return;
        STATE.loadRequested = true;
        let loaded = 0;

        function done() {
            loaded += 1;
            if (loaded < CONFIG.imageCount) return;
            STATE.assetsLoaded = true;
            setTitleLoadingBlink(false);
            rebuildPhotoCache();
            startShow();
        }

        for (let i = 1; i <= CONFIG.imageCount; i++) {
            const img = new Image();
            img.onload = done;
            img.onerror = done;
            img.src = `${CONFIG.imagePrefix}${i}.jpg`;
            images[i] = img;
        }
    }

    function buildPhotoCacheItem(index) {
        const img = images[index];
        if (!img || !img.complete || img.naturalWidth === 0) {
            photoCache[index] = null;
            return;
        }

        const baseR = STATE.minDim * 0.24;
        const size = baseR * 2 + 4;

        const off = document.createElement('canvas');
        off.width = Math.ceil(size * STATE.dpr);
        off.height = Math.ceil(size * STATE.dpr);
        const g = off.getContext('2d');
        if (!g) {
            photoCache[index] = null;
            return;
        }

        g.setTransform(1, 0, 0, 1, 0, 0);
        g.setTransform(STATE.dpr, 0, 0, STATE.dpr, 0, 0);

        const cx = size * 0.5;
        const cy = size * 0.5;

        g.save();
        g.beginPath();
        g.arc(cx, cy, baseR, 0, Math.PI * 2);
        g.clip();

        const ir = img.naturalWidth / img.naturalHeight;
        let dw;
        let dh;
        if (ir >= 1) {
            dh = baseR * 2;
            dw = dh * ir;
        } else {
            dw = baseR * 2;
            dh = dw / ir;
        }
        g.drawImage(img, cx - dw * 0.5, cy - dh * 0.5, dw, dh);

        const featherInner = baseR * (1 - CONFIG.featherRatio);
        const mask = g.createRadialGradient(cx, cy, featherInner, cx, cy, baseR);
        mask.addColorStop(0, 'rgba(255,255,255,1)');
        mask.addColorStop(1, 'rgba(255,255,255,0)');
        g.globalCompositeOperation = 'destination-in';
        g.fillStyle = mask;
        g.beginPath();
        g.arc(cx, cy, baseR, 0, Math.PI * 2);
        g.fill();
        g.restore();

        photoCache[index] = off;
    }

    function rebuildPhotoCache() {
        if (STATE.phase === CONFIG.phase.finale) return;

        photoCacheBuildToken += 1;
        const token = photoCacheBuildToken;
        if (photoCacheBuildRaf) {
            cancelAnimationFrame(photoCacheBuildRaf);
            photoCacheBuildRaf = 0;
        }

        const indices = [];
        for (let i = 1; i <= CONFIG.imageCount; i++) indices.push(i);

        const batchSize = (isMobile || isWeChat) ? 1 : 2;
        const step = () => {
            if (token !== photoCacheBuildToken) return;
            if (STATE.phase === CONFIG.phase.finale) {
                photoCacheBuildRaf = 0;
                return;
            }

            for (let i = 0; i < batchSize && indices.length > 0; i++) {
                const idx = indices.shift();
                buildPhotoCacheItem(idx);
            }

            if (indices.length > 0) {
                photoCacheBuildRaf = requestAnimationFrame(step);
            } else {
                photoCacheBuildRaf = 0;
            }
        };

        photoCacheBuildRaf = requestAnimationFrame(step);
    }

    function pushDt(dt) {
        if (dtCount < CONFIG.dtWindowSize) {
            dtRing[dtIndex] = dt;
            dtSum += dt;
            dtCount += 1;
            dtIndex = (dtIndex + 1) % CONFIG.dtWindowSize;
        } else {
            dtSum -= dtRing[dtIndex];
            dtRing[dtIndex] = dt;
            dtSum += dt;
            dtIndex = (dtIndex + 1) % CONFIG.dtWindowSize;
        }

        STATE.avgDt = dtSum / Math.max(1, dtCount);
        STATE.fps = Math.round(1000 / STATE.avgDt);
    }

    function updateQuality() {
        let target = 1;
        if (STATE.avgDt > 24 || STATE.fps < 38) target = 0.58;
        else if (STATE.avgDt > 20 || STATE.fps < 44) target = 0.72;
        else if (STATE.avgDt > 17 || STATE.fps < 52) target = 0.86;

        STATE.targetQualityScale = target;
        STATE.qualityScale += (STATE.targetQualityScale - STATE.qualityScale) * 0.08;
        STATE.qualityScale = Math.max(0.55, Math.min(1, STATE.qualityScale));

        const shouldLow = STATE.qualityScale < 0.8;
        if (shouldLow && !STATE.lowPowerMode) {
            STATE.lowPowerMode = true;
            STATE.recoverCounter = 0;
            applyViewportSize();
            return;
        }

        if (!shouldLow && STATE.lowPowerMode) {
            if (STATE.avgDt < CONFIG.highExitDt && STATE.fps > CONFIG.highExitFps) {
                STATE.recoverCounter += 1;
                if (STATE.recoverCounter >= CONFIG.highRecoverFrames) {
                    STATE.lowPowerMode = false;
                    STATE.recoverCounter = 0;
                    applyViewportSize();
                }
            } else {
                STATE.recoverCounter = 0;
            }
        }
    }

    function updateEntities(dt, now) {
        if (STATE.phase === CONFIG.phase.photoShow) updatePhotoShow(now);
        else updateFinale(now);

        for (let i = rockets.length - 1; i >= 0; i--) {
            rockets[i].update(dt);
            if (rockets[i].done) rockets.splice(i, 1);
        }

        for (let i = bursts.length - 1; i >= 0; i--) {
            bursts[i].update(dt);
            if (bursts[i].dead) bursts.splice(i, 1);
        }

        for (let i = photoOverlays.length - 1; i >= 0; i--) {
            photoOverlays[i].update(dt);
            if (photoOverlays[i].dead) photoOverlays.splice(i, 1);
        }

        for (let i = activeParticles.length - 1; i >= 0; i--) {
            activeParticles[i].update(dt);
            if (!activeParticles[i].active) recycleParticle(i);
        }
    }

    function drawBackgroundFog(now) {
        if (STATE.phase !== CONFIG.phase.finale) return;
        if (STATE.lowPowerMode) return;
        if ((isMobile || isWeChat) && now < STATE.nextFogAt) return;
        if (isMobile || isWeChat) STATE.nextFogAt = now + 85;

        const t = now * 0.001;
        const alpha = (isMobile || isWeChat) ? 0.045 : 0.058;
        const x = STATE.width * (0.5 + Math.sin(t * 0.17) * 0.18);
        const y = STATE.height * 0.45;
        const r = STATE.minDim * 0.72;

        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, `rgba(170,24,24,${alpha})`);
        g.addColorStop(1, 'rgba(170,24,24,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }

    function draw(now) {
        drawState.stroke = '';
        drawState.fill = '';

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        const clearA = STATE.lowPowerMode ? CONFIG.clearAlphaLow : CONFIG.clearAlphaHigh;
        ctx.fillStyle = `rgba(0,0,0,${clearA})`;
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        drawBackgroundFog(now);

        for (let i = 0; i < rockets.length; i++) rockets[i].draw(ctx);

        let maxBlur = 0;
        for (let i = 0; i < bursts.length; i++) {
            const b = bursts[i].blur();
            if (b > maxBlur) maxBlur = b;
        }

        // lighter ‰ªÖÁî®‰∫éÁÉüËä±Á≤íÂ≠êÊÆµ
        ctx.save();
        const mobileHeavy = (isMobile || isWeChat) && (STATE.lowPowerMode || STATE.fps < 50);
        ctx.globalCompositeOperation = mobileHeavy ? 'source-over' : 'lighter';
        if (maxBlur > 0) {
            let blur = maxBlur;
            if (isMobile || isWeChat) blur = Math.min(2, blur);
            if (STATE.lowPowerMode || STATE.fps < 50) blur = 0;
            ctx.shadowBlur = blur;
            ctx.shadowColor = STATE.phase === CONFIG.phase.finale
                ? 'rgba(255,220,170,0.9)'
                : 'rgba(180,220,255,0.9)';
        } else {
            ctx.shadowBlur = 0;
        }

        for (let i = 0; i < activeParticles.length; i++) {
            activeParticles[i].draw(ctx);
        }

        const flashLite = isMobile || isWeChat;
        const flashMax = flashLite ? ((STATE.lowPowerMode || STATE.fps < 50) ? 2 : 4) : bursts.length;
        let flashCount = 0;
        for (let i = 0; i < bursts.length; i++) {
            if (flashCount >= flashMax) break;
            bursts[i].drawCenterFlash(ctx, flashLite);
            flashCount += 1;
        }
        ctx.restore();

        if (STATE.phase === CONFIG.phase.photoShow) {
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            for (let i = 0; i < photoOverlays.length; i++) {
                photoOverlays[i].draw(ctx);
            }
            ctx.restore();
        }

        if (STATE.phase === CONFIG.phase.finale && CONFIG.finaleEndMode === 'fadeout' && STATE.finaleFading) {
            const p = Math.min(1, (now - STATE.finaleFadeStart) / CONFIG.finaleFadeoutMs);
            ctx.fillStyle = `rgba(0,0,0,${p * 0.9})`;
            ctx.fillRect(0, 0, STATE.width, STATE.height);
        }
    }

    function updateDebug() {
        if (!debugOn) return;
        debugPanel.textContent =
            `FPS: ${STATE.fps}\n` +
            `particles: ${activeParticles.length}\n` +
            `phase: ${STATE.phase}\n` +
            `dpr: ${STATE.dpr.toFixed(2)}\n` +
            `mode: ${STATE.lowPowerMode ? 'LowPower' : 'Normal'}\n` +
            `q: ${STATE.qualityScale.toFixed(2)}`;
    }

    function loop(ts) {
        if (!STATE.running) return;
        rafId = requestAnimationFrame(loop);

        const elapsed = ts - lastTs;
        const dt = elapsed > 120 ? 16.67 : Math.min(40, Math.max(8, elapsed));
        lastTs = ts;

        pushDt(dt);
        updateQuality();
        updateEntities(dt, ts);

        if (STATE.phase === CONFIG.phase.finale && CONFIG.finaleEndMode === 'fadeout' && STATE.finaleFading) {
            if (ts - STATE.finaleFadeStart > CONFIG.finaleFadeoutMs) {
                STATE.nextFinaleVolleyAt = Infinity;
            }
        }

        draw(ts);
        updateDebug();
    }

    function startShow() {
        if (STATE.running) return;
        STATE.running = true;
        STATE.phase = CONFIG.phase.photoShow;
        STATE.mainImageIndex = 1;
        STATE.finalePendingAt = 0;

        const n = nowMs();
        lastTs = n;
        STATE.nextPhotoLaunchAt = n + 250;
        scheduleNextMini(n);

        startOverlay.classList.add('hide');
        setTimeout(() => {
            startOverlay.style.display = 'none';
        }, 850);

        rafId = requestAnimationFrame(loop);
    }

    function bindVisibilityPause() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                STATE.pausedByVisibility = true;
                if (STATE.running && rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = 0;
                }
                return;
            }

            if (STATE.pausedByVisibility && STATE.running) {
                STATE.pausedByVisibility = false;
                lastTs = nowMs();
                if (!rafId) rafId = requestAnimationFrame(loop);
            }
        });
    }

    function bindResize() {
        const onResize = () => {
            if (resizeRaf) return;
            resizeRaf = requestAnimationFrame(() => {
                resizeRaf = 0;
                applyViewportSize();
            });
        };
        window.addEventListener('resize', onResize, { passive: true });
        window.addEventListener('orientationchange', onResize, { passive: true });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', onResize, { passive: true });
        }
    }

    function ensureStarted() {
        if (!STATE.loadRequested) {
            setTitleLoadingBlink(true);
            loadImagesThenStart();
            return;
        }
        if (STATE.assetsLoaded && !STATE.running) startShow();
    }

    function bindStartFallback() {
        const onceStart = () => ensureStarted();
        document.addEventListener('touchstart', onceStart, { passive: true, once: true });
        document.addEventListener('click', onceStart, { passive: true, once: true });
    }

    function bindDebugToggle() {
        if (!debugEnabled) {
            debugToggle.style.display = 'none';
            debugPanel.style.display = 'none';
            return;
        }

        debugToggle.style.display = 'block';
        const toggle = () => {
            debugOn = !debugOn;
            debugToggle.textContent = debugOn ? 'Debug: On' : 'Debug: Off';
            debugPanel.style.display = debugOn ? 'block' : 'none';
        };
        debugToggle.addEventListener('touchstart', toggle, { passive: true });
        debugToggle.addEventListener('click', toggle, { passive: true });
    }

    function init() {
        applyViewportSize();
        bindResize();
        bindDebugToggle();
        bindVisibilityPause();
        bindStartFallback();

        setTitleLoadingBlink(true);
        ensureStarted();
    }

    init();
})();
</script>
</body>
</html>
